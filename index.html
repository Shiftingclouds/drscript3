<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DR Script Builder</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet" />
<script src="scripts/theme.js"></script>
<link rel="stylesheet" href="styles/aurora.css" />
<script defer src="scripts/ui-effects.js"></script>
<script defer src="scripts/perf-metrics.js"></script>
<script defer src="scripts/media-loader.js"></script>
<style>
  :root{
    --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; color:var(--ink); background:radial-gradient(1200px 800px at 10% -10%, rgba(124,108,255,.08), transparent 55%), radial-gradient(900px 700px at 110% 20%, rgba(139,92,246,.06), transparent 60%), var(--bg-primary); font-size:16px; line-height:1.6; font-weight:400; font-family:var(--ff-ui);}

  .app{display:grid; grid-template-columns:280px 1fr; min-height:100vh; transition:opacity .5s; opacity:0; position:relative; z-index:2}

  /* Sidebar */
  .side{background:linear-gradient(180deg, var(--bg-elev), var(--bg-primary)); border-right:1px solid var(--border); padding:22px 16px; position:sticky; top:0; height:100vh; overflow:auto}
  .brand{display:flex; gap:12px; align-items:center; padding:6px 8px 18px}
  .brand .logo{width:28px; height:28px; display:grid; place-items:center; border-radius:10px; background:linear-gradient(145deg, var(--accent), var(--accent-2))}
  .brand h1{margin:0; font-size:22px; line-height:1.2}
  .brand small{display:block; color:var(--faint); font-size:12px; margin-top:4px}
  .nav-section{color:var(--faint); font-weight:600; font-size:12px; margin:18px 10px 8px}
  .nav{display:flex; flex-direction:column; gap:8px}
  .nav button{appearance:none; background:transparent; border:1px solid transparent; color:var(--ink); width:100%; text-align:left; border-radius:12px; padding:12px 14px; display:flex; gap:12px; align-items:center; cursor:pointer}
  .nav button.active{background:var(--bg-1); border-color:var(--border)}
  .nav button:hover{background:var(--bg-1)}

  /* Main */
  .main{padding:28px 28px 80px; overflow:auto}
  h2.title{font-size:36px; margin:0 0 14px}

  .page{
    position:relative;
    z-index:0;
  }
  .page::before{
    content:"";
    position:absolute;
    inset:0;
    background:radial-gradient(circle at 50% 50%, var(--aurora-1), transparent 60%);
    filter:blur(20px);
    opacity:.25;
    pointer-events:none;
    z-index:-1;
  }
  .page-portals::before{
    background:radial-gradient(circle at 20% 20%, var(--aurora-1), transparent 60%), radial-gradient(circle at 80% 80%, var(--aurora-2), transparent 60%);
  }
  .page-journal::before{
    background:radial-gradient(circle at 80% 20%, var(--aurora-2), transparent 60%), radial-gradient(circle at 20% 80%, var(--aurora-4), transparent 60%);
  }
  .page-playlists::before{
    background:radial-gradient(circle at 0% 0%, var(--aurora-3), transparent 60%), radial-gradient(circle at 100% 100%, var(--aurora-1), transparent 60%);
  }
  .page-visualizers::before{
    background:radial-gradient(circle at 100% 0%, var(--aurora-4), transparent 60%), radial-gradient(circle at 0% 100%, var(--aurora-2), transparent 60%);
  }
  .page-scenarios::before{
    background:radial-gradient(circle at 0% 0%, var(--aurora-2), transparent 60%), radial-gradient(circle at 100% 100%, var(--aurora-3), transparent 60%);
  }
  .page-collections::before{
    background:radial-gradient(circle at 50% 0%, var(--aurora-3), transparent 60%), radial-gradient(circle at 50% 100%, var(--aurora-1), transparent 60%);
  }
  .page-waiting::before{
    background:radial-gradient(circle at 50% 0%, var(--aurora-1), transparent 60%), radial-gradient(circle at 50% 100%, var(--aurora-3), transparent 60%);
  }
  .page-lucid::before{
    background:radial-gradient(circle at 0% 50%, var(--aurora-2), transparent 60%), radial-gradient(circle at 100% 50%, var(--aurora-4), transparent 60%);
  }
  .page-astral::before{
    background:radial-gradient(circle at 20% 20%, var(--aurora-3), transparent 60%), radial-gradient(circle at 80% 80%, var(--aurora-4), transparent 60%);
  }
  .page-settings::before{
    background:radial-gradient(circle at 100% 0%, var(--aurora-2), transparent 60%), radial-gradient(circle at 0% 100%, var(--aurora-1), transparent 60%);
  }

  .btn{--bg:linear-gradient(180deg, var(--bg-1), var(--bg-0)); position:relative; color:var(--ink); padding:10px 14px; border-radius:12px; border:1px solid var(--border); cursor:pointer; font-weight:600; display:inline-flex; align-items:center; gap:10px; background:linear-gradient(120deg, rgba(255,255,255,.15), rgba(255,255,255,0)), var(--bg); transition:transform .2s ease}
  .btn::after{content:""; position:absolute; inset:-6px; border-radius:inherit; pointer-events:none; background:conic-gradient(from 0deg at 50% 50%, var(--aurora-1), var(--aurora-2), var(--aurora-3), var(--aurora-4), var(--aurora-1)); filter:blur(12px); opacity:0; transition:opacity .2s ease; z-index:-1}
  .btn:hover{transform:translateY(-1px)}
  .btn:hover::after{opacity:1}
  .btn.primary{--bg:linear-gradient(180deg, var(--aurora-2), var(--aurora-3)); border-color:var(--aurora-2)}
  .btn.ghost{--bg:transparent; background:transparent}
  .btn.small{padding:6px 10px; font-size:13px}

  /* Portals */
  .portal-grid{display:grid; grid-template-columns:repeat(auto-fill, minmax(160px, 1fr)); gap:20px; margin-top:16px}
  .portal-card{display:grid; gap:10px; justify-items:center}
  .portal-circle{width:160px; height:160px; border-radius:50%; border:1px solid var(--border); background:var(--bg-1) center/cover no-repeat; display:grid; place-items:center; color:var(--ink); font-weight:700}
  .portal-circle.add{border:2px dashed var(--border)}
  .portal-circle.add::after{content:'+'; font-size:40px; opacity:.85}
  .portal-name{text-align:center; font-weight:600}
  .portal-actions{display:flex; gap:6px}

  .portal-thumb{
    width:112px;
    height:112px;
    border-radius:50%;
    background-size:cover;
    position:relative;
    z-index:0;
  }
  .portal-thumb::before{
    content:"";
    position:absolute;
    inset:-4px;
    border-radius:inherit;
    background:conic-gradient(from 0deg at 50% 50%, var(--aurora-2), var(--aurora-3), var(--aurora-4), var(--aurora-2));
    -webkit-mask:radial-gradient(farthest-side,transparent calc(100% - 4px), #000 calc(100% - 4px));
    mask:radial-gradient(farthest-side,transparent calc(100% - 4px), #000 calc(100% - 4px));
    filter:blur(2px);
    animation:pulse 3.6s ease-in-out infinite;
    pointer-events:none;
  }

  /* Waiting Rooms */
  .wr-grid{display:grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap:20px; margin-top:10px}
  .wr-card{display:grid; gap:8px}
  .wr-thumb{width:180px; height:180px; border-radius:18px; border:1px solid var(--border); background:var(--bg-1) center/cover no-repeat; position:relative; display:grid; place-items:center; color:var(--ink); font-weight:700; font-size:18px; text-align:center}
  .wr-thumb .badge{position:absolute; top:8px; right:8px; background:#0008; color:var(--ink); font-size:11px; padding:4px 6px; border-radius:8px}
  .wr-thumb.new{border:2px dashed var(--border);} .wr-thumb.new::after{content:'+'; font-size:38px; opacity:.85}
  .wr-label{text-align:center; font-weight:600}
  .wr-actions{display:flex; gap:6px; justify-content:center}
  .modal-grid.wr{grid-template-columns:120px 1fr}
  .wr-thumb.edit{cursor:pointer}

  /* Playlists */
  .pl-grid{display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:20px; margin-top:10px}
  .pl-card{display:grid; gap:8px}
  .pl-thumb{width:200px; height:140px; border-radius:14px; border:1px solid var(--border); background:var(--bg-1) center/cover no-repeat; position:relative; display:grid; place-items:center; color:var(--ink); font-weight:700; text-align:center}
  .pl-thumb.new{border:2px dashed var(--border);} .pl-thumb.new::after{content:'+'; font-size:36px; opacity:.85}
  .pl-label{text-align:center; font-weight:600}
  .track-list{border:1px solid var(--border); border-radius:12px; padding:8px; display:grid; gap:8px; max-height:220px; overflow:auto; background:var(--bg-0)}
  .track{display:grid; grid-template-columns:1fr auto auto; gap:8px; align-items:center; padding:8px; border:1px solid var(--border); border-radius:10px; background:var(--bg-1)}
  .track a{color:var(--aurora-3); text-decoration:none}

  /* Journal */
  .journal-toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0}
  .tagbar{display:flex; gap:8px; flex-wrap:wrap}
  .tag{padding:6px 10px; border:1px solid var(--border); border-radius:999px; cursor:pointer; font-size:12px; background:var(--bg-1)}
  .tag.active{outline:2px solid var(--aurora-2)}
  .journal-list{display:grid; gap:12px; margin-top:10px}
  .scenario-list{display:grid; gap:12px; margin-top:10px}
  .scenario-card{background:var(--bg-1); border:1px solid var(--border); border-radius:14px; padding:14px; display:grid; gap:6px}
  .scenario-actions{display:flex; gap:6px; justify-content:flex-end}
  .image-strip{display:flex; gap:6px; flex-wrap:wrap; margin-top:6px}
  .image-thumb{width:60px; height:60px; background:var(--bg-0) center/cover no-repeat; border-radius:8px; position:relative; cursor:pointer}
  .image-thumb .remove{position:absolute; top:-6px; right:-6px; background:rgba(0,0,0,.6); color:var(--ink); border:none; border-radius:50%; width:18px; height:18px; display:grid; place-items:center; font-size:12px; cursor:pointer}
  .pick-gallery{display:flex; flex-wrap:wrap; gap:8px; max-height:50vh; overflow:auto}
  .pick-thumb{width:80px; height:80px; background:var(--bg-0) center/cover no-repeat; border:2px solid transparent; border-radius:8px; cursor:pointer}
  .pick-thumb.selected{border-color:var(--aurora-2)}
  .collection-list{display:grid; gap:12px; margin-top:10px}
  .collection-item{background:var(--bg-1); border:1px solid var(--border); border-radius:14px; padding:14px; display:flex; justify-content:space-between; align-items:center}
  .collection-actions{display:flex; gap:6px}
  .entry{background:var(--bg-1); border:1px solid var(--border); border-radius:14px; padding:14px}
  .entry h4{margin:0 0 6px}
  .entry .meta{color:var(--faint); font-size:12px; display:flex; gap:10px; align-items:center}
  .entry .tags{display:flex; gap:6px; flex-wrap:wrap; margin-top:6px}

  /* Inputs */
  .field{margin-bottom:16px}
  .label{display:block; color:var(--muted); font-size:12px; margin-bottom:6px}
  .text, .textarea, select{width:100%; background:var(--bg-0); color:var(--ink); border:1px solid var(--border); border-radius:10px; padding:10px 12px}
  .textarea{min-height:130px; resize:vertical}

  /* RTE */
  .rte{background:var(--bg-0); border:1px solid var(--border); border-radius:12px; overflow:hidden}
  .rte .rtebar{display:flex; gap:6px; padding:8px; border-bottom:1px solid var(--border); background:var(--bg-1)}
  .rte .rtebar button{background:var(--bg-1); border:1px solid var(--border); color:var(--ink); padding:6px 8px; border-radius:8px; cursor:pointer}
  .rte .rtebar input[type="file"]{display:none}
  .rte .area{min-height:240px; padding:14px; outline:none}
  .rte .area img{max-width:100%; border-radius:10px; border:1px solid var(--border)}
  #scenarioDesc.question-placeholder{color:var(--muted)}

  /* Drawer + Modals */
  .drawer{position:fixed; inset:auto 0 0 0; height:78vh; background:linear-gradient(180deg, var(--bg-1), var(--bg-0)); border-top:1px solid var(--border); box-shadow:var(--shadow); translate:0 110%; transition:.25s ease; z-index:200}
  .drawer.open{translate:0 0}
  .drawer-overlay{position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:199}
  .drawer .sections{border-right:1px solid var(--border); padding:16px; overflow:auto}
  .drawer .editor{padding:18px; overflow:auto}

  .modal{position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.4); z-index:100}
  .modal.open{display:grid}
  .modal-card{background:var(--bg-1); border:1px solid var(--border); border-radius:16px; padding:18px; width:min(560px,95vw)}
  .modal-grid{display:grid; grid-template-columns:1fr 2fr; gap:14px}

  /* Lightbox needs higher z-index than regular modals */
  #lightbox{z-index:200}
  
  /* Confirm modal needs highest z-index to appear above lightbox */
  #confirmModal{z-index:300}

  .empty{border:1px dashed var(--border); color:var(--muted); border-radius:16px; padding:32px; display:grid; place-items:center}
  .actions{display:flex; gap:8px; justify-content:flex-end; margin-top:12px}

  /* Lucid Dreaming Styles */
  .lucid-toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0}
  .tab-btn{background:var(--bg-elev); border:1px solid var(--border); color:var(--ink); padding:8px 16px; border-radius:8px; cursor:pointer; font-size:14px; transition:.2s ease}
  .tab-btn.active{background:var(--accent); color:var(--ink); border-color:var(--accent)}
  .tab-btn:hover{border-color:var(--accent)}
  .tab-content{margin-top:16px}
  .progress-card{background:var(--bg-card); border:1px solid var(--border); border-radius:12px; padding:16px}
  .progress-card h3{margin:0 0 12px; color:var(--ink)}
  .stat-display{margin-bottom:12px}
  .stat-number{font-size:24px; font-weight:700; color:var(--accent); display:block}
  .stat-label{color:var(--muted); font-size:12px}
  .mini-chart{height:60px; background:var(--bg-elev); border-radius:8px; display:flex; align-items:end; gap:2px; padding:4px}
  .chart-bar{background:var(--accent); border-radius:2px; min-height:4px; flex:1; opacity:.7; transition:.2s ease}
  .chart-bar:hover{opacity:1}
  .goals-list{display:grid; gap:8px}
  .goal-item{background:var(--bg-elev); border:1px solid var(--border); border-radius:8px; padding:12px; display:flex; justify-content:space-between; align-items:center}
  .goal-item.completed{opacity:.7; text-decoration:line-through}
  .goal-actions{display:flex; gap:6px}
  .technique-card{background:var(--bg-card); border:1px solid var(--border); border-radius:12px; padding:16px}
  .technique-card h4{margin:0 0 8px; color:var(--ink)}
  .technique-rating{display:flex; gap:4px; margin:8px 0}
  .star{color:var(--muted); cursor:pointer; font-size:16px; transition:.2s ease}
  .star.filled{color:var(--aurora-4)}
  .dream-entry{background:var(--bg-card); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:12px}
  .dream-header{display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px}
  .dream-meta{display:flex; flex-direction:column; gap:4px}
  .dream-badges{display:flex; gap:6px; flex-wrap:wrap; margin-top:6px}
  .dream-badge{padding:2px 8px; border-radius:12px; font-size:11px; font-weight:600}
  .dream-badge.lucid{background:rgba(124,108,255,.2); color:var(--accent)}
  .dream-badge.semi{background:rgba(139,92,246,.2); color:var(--accent-2)}
  .dream-badge.normal{background:rgba(123,127,136,.2); color:var(--muted)}
  .dream-badge.nightmare{background:rgba(239,68,68,.2); color:#ef4444}
  .projection-entry{background:var(--bg-card); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:12px}
  .projection-header{display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:12px}
  .projection-meta{display:flex; flex-direction:column; gap:4px}
  .projection-badges{display:flex; gap:6px; flex-wrap:wrap; margin-top:6px}
  .projection-badge{padding:2px 8px; border-radius:12px; font-size:11px; font-weight:600}
  .projection-badge.full{background:rgba(124,108,255,.2); color:var(--accent)}
  .projection-badge.partial{background:rgba(139,92,246,.2); color:var(--accent-2)}
  .projection-badge.vibrations{background:rgba(34,197,94,.2); color:#22c55e}
  .projection-badge.failed{background:rgba(239,68,68,.2); color:#ef4444}
  .location-btn{background:var(--bg-elev); border:1px solid var(--border); color:var(--muted); padding:4px 8px; border-radius:6px; cursor:pointer; font-size:12px; transition:.2s ease}
  .location-btn.active{background:var(--accent); color:var(--ink); border-color:var(--accent)}
  .location-btn:hover{border-color:var(--accent)}
  .goals-summary{display:grid; gap:4px; font-size:12px}
  .goals-summary-item{display:flex; justify-content:space-between; color:var(--muted)}
  .emotion-btn, .rc-btn{background:var(--bg-elev); border:1px solid var(--border); color:var(--muted); padding:4px 8px; border-radius:6px; cursor:pointer; font-size:12px; transition:.2s ease}
  .emotion-btn.active, .rc-btn.active{background:var(--accent); color:var(--ink); border-color:var(--accent)}
  .emotion-btn.hover, .rc-btn:hover{border-color:var(--accent)}
  .journal-tag{padding:4px 8px; border:1px solid var(--border); border-radius:12px; font-size:11px; background:var(--bg-1)}

  @media (max-width: 920px){ .app{grid-template-columns:74px 1fr} .brand h1, .brand small{display:none} .nav button span{display:none} }

  /* Visualizers */
  .viz-toolbar{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0}
  .viz-group{margin:18px 0}
  .viz-group h3{margin:0 0 10px; font-size:18px; color:var(--muted)}
  .viz-grid{display:grid; grid-template-columns:repeat(auto-fill, minmax(140px,1fr)); gap:12px}
  .viz-thumb{position:relative; width:100%; padding-top:100%; border:1px solid var(--border); border-radius:14px; background:var(--bg-0) center/cover no-repeat; cursor:pointer; overflow:hidden}
  .viz-thumb .cap{position:absolute; inset:auto 0 0 0; padding:6px 8px; background:linear-gradient(180deg, transparent, rgba(0,0,0,.55)); font-size:12px}
  #launchScene{position:fixed; inset:0; background:rgba(10,14,22,0.4); transition:opacity .5s; z-index:2}
/* Launch scene canvas with subtle orb glow */
#launchScene canvas{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  /* subtle glow and shadow around orbs */
  filter: drop-shadow(0 0 6px rgba(255,255,255,.15))
          drop-shadow(0 2px 4px rgba(0,0,0,.6));
}

#starfieldContainer canvas{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
}

/* Portal canvas inside main app view */
#portals-view{position:relative}
#portals-view #portalCanvas{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  filter: drop-shadow(0 0 6px rgba(255,255,255,.15))
          drop-shadow(0 2px 4px rgba(0,0,0,.6));
}

/* Enter App button: centered, styled, animated, fixed to viewport */
#enterApp{
  position:fixed;            /* <- fixed so it ignores canvas panning/zoom */
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  z-index:1000;
  padding:14px 32px;
  border:2px solid var(--aurora-3);
  border-radius:999px;
  background:transparent;
  color:var(--ink);
  font-size:16px;
  font-weight:600;
  cursor:pointer;
  box-shadow:none;
  transition:background .3s, transform .2s;
  touch-action:manipulation;
}

.enter-label{
  padding:6px 16px;
  border-radius:6px;
  display:inline-block;
  background:transparent;
  box-shadow:none;
}

#enterApp::before,
#enterApp::after,
button::-moz-focus-inner{
  background:transparent;
  box-shadow:none;
  border:0;
  padding:0;
}

#enterApp:hover,
#enterApp:focus{
  animation:enterPulse 1.2s ease-in-out alternate infinite;
  box-shadow:none;
}
#enterApp:hover .enter-label,
#enterApp:focus .enter-label{
  text-shadow:0 0 8px var(--aurora-3);
}

#enterApp:active{
  transform:translate(-50%,-50%) scale(.97);
  box-shadow:none;
}

@keyframes pulse{
  0%,100%{transform:scale(1); opacity:1;}
  50%{transform:scale(1.05); opacity:.7;}
}

@keyframes enterPulse{
  from{ transform:translate(-50%,-50%) scale(1);   box-shadow:0 0 12px rgba(30,58,138,.4); }
  to  { transform:translate(-50%,-50%) scale(1.05); box-shadow:0 0 18px rgba(30,58,138,.6); }
}

</style>
</head>
<body class="theme-aurora">
<div id="starfieldContainer" style="position:fixed; inset:0; z-index:0;">
  <canvas id="starfieldCanvas"></canvas>
</div>
<div id="launchScene"><canvas id="portalCanvas"></canvas><button id="enterApp"><span class="enter-label">Enter Tracking App</span></button></div>
<div class="app" style="display:none">
  <div id="headerOverflow" class="header-overflow" style="position:absolute; top:16px; right:16px; z-index:10;">
    <button class="btn small" id="qaRestore">Sync From Dropbox</button>
    <button class="btn small" id="viewConflictLog">Conflict Log</button>
    <button class="btn small" id="undoRestore" style="display:none">Undo Restore</button>
  </div>
  <aside class="side">
    <div class="brand">
      <div class="logo">‚ú®</div>
      <div>
        <h1>DR Script Builder</h1>
        <small>Reality Shifting Companion</small>
      </div>
    </div>
    <div style="display:flex; gap:6px; margin:10px 0">
      <select id="librarySelect" class="text" style="flex:1"></select>
      <button class="btn small" id="libraryAdd">Ôºã</button>
      <button class="btn small" id="libraryDelete">‚úï</button>
    </div>

    <div class="nav-section">MAIN</div>
    <div class="nav">
      <button data-view="portals" class="active">üåü <span>My Portals</span></button>
      <button data-view="journal">üìñ <span>Journal</span></button>
      <button data-view="playlists">üéµ <span>Playlists</span></button>
      <button data-view="visualizers">üñºÔ∏è <span>Visualizers</span></button>
      <button data-view="scenarios">üìù <span>Scenarios</span></button>
      <button data-view="collections">üìö <span>Collections</span></button>
    </div>

    <div class="nav-section">SPECIAL</div>
    <div class="nav">
      <button data-view="waiting">‚è≥ <span>Waiting Rooms</span></button>
      <button data-view="lucid">üåô <span>Lucid Dreaming</span></button>
      <button data-view="astral">‚ú® <span>Astral Projection</span></button>
    </div>

    <div class="nav-section" style="margin-top:22px">SYSTEM</div>
    <div class="nav">
      <button data-view="settings">‚öôÔ∏è <span>Settings</span></button>
    </div>
  </aside>

  <main class="main">
    <!-- Portals View -->
    <section id="portals-view" class="view page page-portals">
      <h2 class="title">My DR Portals</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Create and manage your portals to different realities</p>
      <div id="portalGrid" class="portal-grid"></div>
      <div id="portalEmpty" class="empty" style="display:none">Create your first portal to begin ‚ú®</div>
    </section>

    <!-- Journal View -->
    <section id="journal-view" class="view page page-journal" hidden>
      <h2 class="title">Journal</h2>
      <div class="toolbar"><button class="btn primary" id="newEntry">Ôºã New Entry</button></div>
      <div class="journal-toolbar">
        <input id="jSearch" class="text" placeholder="Search journal..." style="min-width:220px" />
        <select id="jSort" class="text" style="max-width:200px">
          <option value="date_desc">Newest first</option>
          <option value="date_asc">Oldest first</option>
          <option value="title_asc">Title A‚ÜíZ</option>
          <option value="title_desc">Title Z‚ÜíA</option>
        </select>
        <select id="jPortalFilter" class="text" style="max-width:240px"><option value="">All portals</option></select>
        <div id="jTagBar" class="tagbar"></div>
      </div>
      <div id="journalList" class="journal-list"></div>
      <div id="journalEmpty" class="empty" style="display:none">No entries yet</div>
    </section>

    <!-- Playlists View -->
    <section id="playlists-view" class="view page page-playlists" hidden>
      <h2 class="title">Playlists</h2>
      <div class="journal-toolbar">
        <input id="plSearch" class="text" placeholder="Search playlists or tracks..." style="min-width:240px"/>
        <select id="plPortalFilter" class="text" style="max-width:240px"><option value="">All portals</option></select>
      </div>
      <div id="plGrid" class="pl-grid"></div>
      <div id="plEmpty" class="empty" style="display:none">No playlists yet</div>
    </section>

    <!-- Visualizers View -->
    <section id="visualizers-view" class="view page page-visualizers" hidden>
      <h2 class="title">Visualizers</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Browse all images by portal. Click a thumbnail to view full-size.</p>
      <div class="viz-toolbar">
        <button class="btn primary" id="vizUploadBtn">Ôºã Upload Images</button>
        <input id="vizSearch" class="text" placeholder="Search by name or tag..." style="min-width:240px"/>
        <select id="vizPortalFilter" class="text" style="max-width:240px"><option value="">All portals</option></select>
      </div>
      <div id="vizTagBar" class="tagbar"></div>
      <div id="vizContainer"></div>
      <div id="vizEmpty" class="empty" style="display:none">No media found</div>
    </section>

    <!-- Scenarios View -->
    <section id="scenarios-view" class="view page page-scenarios" hidden>
      <h2 class="title">Scenarios</h2>
      <div class="toolbar">
        <select id="scenarioTemplate" style="width:auto; margin-right:8px">
          <option value="">Select Template...</option>
        </select>
        <button class="btn primary" id="scenarioCreate">Ôºã New Scenario</button>
      </div>
      <div id="scenarioTagBar" class="tagbar"></div>
      <div class="toolbar">
        <input id="scenarioSearch" class="text" placeholder="Search scenarios..." style="min-width:240px"/>
        <select id="scenarioFilter" class="text" style="max-width:240px">
          <option value="">All metadata</option>
          <option value="tag">Tags</option>
          <option value="location">Location</option>
          <option value="character">Characters</option>
        </select>
      </div>
      <div id="scenarioList" class="scenario-list"></div>
      <div id="scenarioEmpty" class="empty" style="display:none">No scenarios yet</div>
    </section>

    <!-- Collections View -->
    <section id="collections-view" class="view page page-collections" hidden>
      <h2 class="title">Collections</h2>
      <div class="toolbar">
        <button class="btn primary" id="collectionCreate">Ôºã New Collection</button>
      </div>
      <div id="collectionList" class="collection-list"></div>
      <div id="collectionEmpty" class="empty" style="display:none">No collections yet</div>
    </section>

    <!-- Waiting Rooms -->
    <section id="waiting-view" class="view page page-waiting" hidden>
      <h2 class="title">Waiting Rooms</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Create calming spaces and link them to portals.</p>
      <div id="wrGrid" class="wr-grid"></div>
    </section>

    <!-- Lucid Dreaming View -->
    <section id="lucid-view" class="view page page-lucid" hidden>
      <h2 class="title">Lucid Dreaming</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Track your lucid dreams, set goals, and monitor your progress</p>
      
      <div class="lucid-tabs" style="display:flex; gap:8px; margin:16px 0; border-bottom:1px solid var(--border); padding-bottom:8px">
        <button class="tab-btn active" data-tab="dreams">üåô Dream Journal</button>
        <button class="tab-btn" data-tab="goals">üéØ Goals & Tasks</button>
        <button class="tab-btn" data-tab="techniques">‚ö° Techniques</button>
        <button class="tab-btn" data-tab="progress">üìä Progress</button>
      </div>

      <!-- Dream Journal Tab -->
      <div id="dreams-tab" class="tab-content">
        <div class="toolbar">
          <button class="btn primary" id="newDream">Ôºã New Dream</button>
          <button class="btn" id="exportDreams">‚¨á Export Dreams</button>
        </div>
        <div class="lucid-toolbar">
          <input id="dreamSearch" class="text" placeholder="Search dreams..." style="min-width:220px"/>
          <select id="dreamSort" class="text" style="max-width:200px">
            <option value="date_desc">Newest first</option>
            <option value="date_asc">Oldest first</option>
            <option value="lucidity_desc">Most lucid first</option>
            <option value="vividness_desc">Most vivid first</option>
          </select>
          <select id="dreamLucidFilter" class="text" style="max-width:200px">
            <option value="">All dreams</option>
            <option value="lucid">Lucid only</option>
            <option value="semi">Semi-lucid</option>
            <option value="normal">Normal dreams</option>
          </select>
        </div>
        <div id="dreamList" class="journal-list"></div>
        <div id="dreamEmpty" class="empty" style="display:none">No dreams recorded yet</div>
      </div>

      <!-- Goals & Tasks Tab -->
      <div id="goals-tab" class="tab-content" hidden>
        <div class="toolbar">
          <button class="btn primary" id="newGoal">Ôºã New Goal</button>
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-top:16px">
          <div>
            <h3 style="margin:0 0 12px">Active Goals</h3>
            <div id="activeGoals" class="goals-list"></div>
          </div>
          <div>
            <h3 style="margin:0 0 12px">Completed Goals</h3>
            <div id="completedGoals" class="goals-list"></div>
          </div>
        </div>
      </div>

      <!-- Techniques Tab -->
      <div id="techniques-tab" class="tab-content" hidden>
        <div class="toolbar">
          <button class="btn primary" id="newTechnique">Ôºã Add Technique</button>
        </div>
        <div id="techniquesList" style="display:grid; gap:16px; margin-top:16px"></div>
      </div>

      <!-- Progress Tab -->
      <div id="progress-tab" class="tab-content" hidden>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(300px, 1fr)); gap:20px; margin-top:16px">
          <div class="progress-card">
            <h3>Dream Recall</h3>
            <div class="stat-display">
              <span id="recallRate" class="stat-number">0%</span>
              <span class="stat-label">Last 30 days</span>
            </div>
            <div id="recallChart" class="mini-chart"></div>
          </div>
          <div class="progress-card">
            <h3>Lucidity Rate</h3>
            <div class="stat-display">
              <span id="lucidityRate" class="stat-number">0%</span>
              <span class="stat-label">Last 30 days</span>
            </div>
            <div id="lucidityChart" class="mini-chart"></div>
          </div>
          <div class="progress-card">
            <h3>Goals Achieved</h3>
            <div class="stat-display">
              <span id="goalsAchieved" class="stat-number">0</span>
              <span class="stat-label">Total completed</span>
            </div>
            <div id="goalsProgress" class="goals-summary"></div>
          </div>
          <div class="progress-card">
            <h3>Dream Frequency</h3>
            <div class="stat-display">
              <span id="dreamFreq" class="stat-number">0</span>
              <span class="stat-label">Dreams per week</span>
            </div>
            <div id="frequencyChart" class="mini-chart"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Astral Projection View -->
    <section id="astral-view" class="view page page-astral" hidden>
      <h2 class="title">Astral Projection</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Track your out-of-body experiences, set projection goals, and monitor your progress</p>
      
      <div class="lucid-tabs" style="display:flex; gap:8px; margin:16px 0; border-bottom:1px solid var(--border); padding-bottom:8px">
        <button class="tab-btn active" data-tab="projections">‚ú® Projection Journal</button>
        <button class="tab-btn" data-tab="astral-goals">üéØ Goals & Tasks</button>
        <button class="tab-btn" data-tab="astral-techniques">‚ö° Techniques</button>
        <button class="tab-btn" data-tab="astral-progress">üìä Progress</button>
      </div>

      <!-- Projection Journal Tab -->
      <div id="projections-tab" class="tab-content">
        <div class="toolbar">
          <button class="btn primary" id="newProjection">Ôºã New Projection</button>
          <button class="btn" id="exportProjections">‚¨á Export Projections</button>
        </div>
        <div class="lucid-toolbar">
          <input id="projectionSearch" class="text" placeholder="Search projections..." style="min-width:220px"/>
          <select id="projectionSort" class="text" style="max-width:200px">
            <option value="date_desc">Newest first</option>
            <option value="date_asc">Oldest first</option>
            <option value="clarity_desc">Most clear first</option>
            <option value="duration_desc">Longest first</option>
          </select>
          <select id="projectionTypeFilter" class="text" style="max-width:200px">
            <option value="">All experiences</option>
            <option value="full">Full Projection</option>
            <option value="partial">Partial Projection</option>
            <option value="vibrations">Vibrations Only</option>
            <option value="failed">Failed Attempt</option>
          </select>
        </div>
        <div id="projectionList" class="journal-list"></div>
        <div id="projectionEmpty" class="empty" style="display:none">No projections recorded yet</div>
      </div>

      <!-- Goals & Tasks Tab -->
      <div id="astral-goals-tab" class="tab-content" hidden>
        <div class="toolbar">
          <button class="btn primary" id="newAstralGoal">Ôºã New Goal</button>
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-top:16px">
          <div>
            <h3 style="margin:0 0 12px">Active Goals</h3>
            <div id="activeAstralGoals" class="goals-list"></div>
          </div>
          <div>
            <h3 style="margin:0 0 12px">Completed Goals</h3>
            <div id="completedAstralGoals" class="goals-list"></div>
          </div>
        </div>
      </div>

      <!-- Techniques Tab -->
      <div id="astral-techniques-tab" class="tab-content" hidden>
        <div class="toolbar">
          <button class="btn primary" id="newAstralTechnique">Ôºã Add Technique</button>
        </div>
        <div id="astralTechniquesList" style="display:grid; gap:16px; margin-top:16px"></div>
      </div>

      <!-- Progress Tab -->
      <div id="astral-progress-tab" class="tab-content" hidden>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(300px, 1fr)); gap:20px; margin-top:16px">
          <div class="progress-card">
            <h3>Success Rate</h3>
            <div class="stat-display">
              <span id="astralSuccessRate" class="stat-number">0%</span>
              <span class="stat-label">Last 30 days</span>
            </div>
            <div id="astralSuccessChart" class="mini-chart"></div>
          </div>
          <div class="progress-card">
            <h3>Average Duration</h3>
            <div class="stat-display">
              <span id="astralDuration" class="stat-number">0</span>
              <span class="stat-label">Minutes per session</span>
            </div>
            <div id="astralDurationChart" class="mini-chart"></div>
          </div>
          <div class="progress-card">
            <h3>Goals Achieved</h3>
            <div class="stat-display">
              <span id="astralGoalsAchieved" class="stat-number">0</span>
              <span class="stat-label">Total completed</span>
            </div>
            <div id="astralGoalsProgress" class="goals-summary"></div>
          </div>
          <div class="progress-card">
            <h3>Projection Frequency</h3>
            <div class="stat-display">
              <span id="astralFreq" class="stat-number">0</span>
              <span class="stat-label">Attempts per week</span>
            </div>
            <div id="astralFrequencyChart" class="mini-chart"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Settings View -->
    <section id="settings-view" class="view page page-settings" hidden>
      <h2 class="title">Settings</h2>
      <p style="color:var(--muted); margin:-4px 0 14px">Connect Dropbox to sync your data across devices.</p>
      <div class="field"><label class="label">Dropbox App Key (from your Dropbox App Console)</label><input id="dbxAppKey" class="text" placeholder="paste your App Key"/></div>
      <div class="field"><label class="label">Access Token (optional ‚Äì paste a generated token if you prefer not to use OAuth)</label><input id="dbxAccessToken" class="text" placeholder="paste short-lived access token"/></div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:12px 0">
        <button class="btn" id="dbxConnect">Connect Dropbox (OAuth)</button>
        <button class="btn" id="dbxSaveToken">Save Token</button>
        <button class="btn" id="testConnection">Test Connection</button>
        <button class="btn" id="dbxDisconnect">Disconnect</button>
      </div>
      <div class="field"><label class="label">Sync File Path (in your Dropbox)</label><input id="dbxPath" class="text" value="/Apps/DR Script Builder/data.json"/></div>
      <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap" class="field">
        <label style="display:flex; gap:8px; align-items:center"><input type="checkbox" id="autoSyncToggle"/> Auto Sync</label>
        <label style="display:flex; gap:8px; align-items:center">Every <input id="autoSyncMins" class="text" style="width:80px" value="5"/> min</label>
        <button class="btn" id="syncNow">Sync Now</button>
        <button class="btn" id="restoreFromDropbox">Sync From Dropbox</button>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:12px 0" class="field">
        <button class="btn" id="exportAll">Export All (JSON)</button>
        <button class="btn" id="importBtn">Import JSON</button>
        <input id="importFile" type="file" accept="application/json" style="display:none" />
      </div>
      <div id="syncStatus" style="color:var(--muted); font-size:13px">Status: Not connected</div>
      <div style="margin-top:14px; color:var(--faint); font-size:13px">
        Tip: For OAuth, add the current page URL to your Dropbox App's <em>Redirect URIs</em>. After login, you should return here with a <code>code</code> in the URL.
      </div>
    </section>
  </main>
</div>

<!-- Modals -->
<div class="modal" id="confirmModal" aria-hidden="true">
  <div class="modal-card" style="max-width:420px">
<p id="confirmText" style="margin:6px 0 12px; color:var(--ink)">Are you sure?</p>
    <div class="actions"><button class="btn ghost" id="confirmCancel">Cancel</button><button class="btn primary" id="confirmOk">Yes</button></div>
  </div>
</div>

<div class="modal" id="restoreModal" aria-hidden="true">
  <div class="modal-card" style="max-width:420px">
    <h3 style="margin:0 0 12px">Restore Options</h3>
    <div class="field">
      <label class="label">Restore Target</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="radio" name="restoreTarget" value="latest" checked/> Latest backup</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="radio" name="restoreTarget" value="file"/> Choose file<input type="file" id="restoreFile" accept="application/json" style="display:none; margin-left:8px"/></label>
    </div>
    <div class="field" style="margin-top:12px">
      <label class="label">Strategy</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="radio" name="restoreStrategy" value="overwrite" checked/> Overwrite</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="radio" name="restoreStrategy" value="merge"/> Merge</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="radio" name="restoreStrategy" value="preview"/> Preview</label>
    </div>
    <div class="field" style="margin-top:12px">
      <label class="label">Include</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="restoreAppState" checked/> App State</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="restoreScenarios" checked/> Scenarios</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="restoreMedia" checked/> Media</label>
      <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="restoreSettings" checked/> Settings</label>
    </div>
    <div class="actions"><button class="btn ghost" id="restoreCancel">Cancel</button><button class="btn primary" id="restoreConfirm">Restore</button></div>
</div>
</div>

<div class="modal" id="conflictLogModal" aria-hidden="true">
  <div class="modal-card" style="max-width:600px">
    <h3 style="margin:0 0 12px">Conflict Log</h3>
    <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
      <select id="conflictTypeFilter"></select>
      <input type="date" id="conflictStartDate"/>
      <input type="date" id="conflictEndDate"/>
    </div>
    <pre id="conflictLogEntries" style="max-height:300px; overflow:auto; background:var(--surface); padding:8px;"></pre>
    <div class="actions"><button class="btn ghost" id="conflictClose">Close</button></div>
  </div>
</div>

<div class="modal" id="portalModal" aria-hidden="true">
  <div class="modal-card">
    <h3 style="margin:0 0 8px">Create Portal</h3>
    <div class="modal-grid">
      <div style="display:grid; gap:8px; align-content:start">
        <div id="pCoverPreview" class="portal-circle" style="width:120px; height:120px; border-radius:50%;">IMG</div>
        <label class="btn small" style="justify-content:center">Upload Image<input id="pCoverInput" type="file" accept="image/*" style="display:none"/></label>
      </div>
      <div>
        <div class="field"><label class="label">Portal Name</label><input id="pNameInput" class="text" placeholder="e.g. Avengers Tower"/></div>
      </div>
    </div>
    <div class="actions" style="margin-top:10px"><button class="btn ghost" id="pCancel">Cancel</button><button class="btn primary" id="pCreate">Create</button></div>
  </div>
</div>

<div class="modal" id="portalSummaryModal" aria-hidden="true" aria-modal="true" role="dialog">
  <div id="portalSummaryCard" class="modal-card" style="width:min(720px,95vw); max-height:90vh; overflow-y:auto"></div>
</div>

<div class="modal" id="wrModal" aria-hidden="true">
  <div class="modal-card">
    <h3 id="wrModalTitle" style="margin:0 0 8px">Edit Waiting Room</h3>
    <div class="modal-grid wr">
      <div>
        <div id="wrThumbEdit" class="wr-thumb edit" style="width:120px; height:120px; border-radius:12px">Name</div>
        <label class="btn small" style="margin-top:8px; justify-content:center">Upload Image<input id="wrImgInput" type="file" accept="image/*" style="display:none"/></label>
      </div>
      <div>
        <div class="field"><label class="label">Name</label><input id="wrName" class="text"/></div>
        <div class="field"><label class="label">Use as default</label><label style="display:flex; gap:8px; align-items:center"><input type="checkbox" id="wrDefault"/> <span class="muted">New portals link to this by default</span></label></div>
        <div class="field"><label class="label">Description</label>
          <div class="rte"><div class="rtebar"><button data-cmd="bold">B</button><button data-cmd="italic"><em>I</em></button><button data-cmd="underline"><u>U</u></button><button data-cmd="insertUnorderedList">‚Ä¢ List</button><button data-cmd="insertOrderedList">1. List</button><label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üñº Add Image<input type="file" accept="image/*" data-img="wr"></label><label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üé¨ Add Video<input type="file" accept="video/*" data-vid="wr"></label></div><div id="wrDesc" class="area" contenteditable="true"></div></div>
        </div>
        <div class="field"><label class="label">Affirmations (one per line)</label><textarea id="wrAff" class="textarea"></textarea></div>
        <div class="field"><label class="label">Pre-shift Checklist</label><div style="display:flex; gap:8px"><input id="wrChecklistItem" class="text" placeholder="Add checklist item"/><button class="btn" id="wrAddItem">Add</button></div><ul id="wrChecklist" style="margin:8px 0 0 18px"></ul></div>
        <div class="field"><label class="label">Optional timer (minutes)</label><input id="wrTimer" class="text" placeholder="e.g. 10"/></div>
      </div>
    </div>
    <div class="actions"><button class="btn ghost" id="wrCancel">Cancel</button><button class="btn primary" id="wrSave">Save</button></div>
  </div>
</div>

<div class="modal" id="journalModal" aria-hidden="true">
  <div class="modal-card" style="width:min(960px,95vw); max-height:90vh; overflow-y:auto">
    <h3 id="jModalTitle" style="margin:0 0 10px">New Entry</h3>
    <div class="modal-grid" style="grid-template-columns:1fr 2fr">
      <div>
        <div class="field"><label class="label">Title</label><input id="jTitle" class="text" placeholder="Entry title"/></div>
        <div class="field"><label class="label">Date</label><input id="jDate" type="datetime-local" class="text"/></div>
        <div class="field"><label class="label">Portal</label><select id="jPortal" class="text"></select></div>
        <div class="field"><label class="label">Add Tag(s)</label><input id="jTagsInput" class="text" placeholder="Type and press Enter (or comma)"/></div>
        <div class="field"><label class="label">Tags</label><div id="jTags" class="tagbar"></div></div>
      </div>
      <div>
        <div class="field"><label class="label">Entry</label><div class="rte"><div class="rtebar"><button data-cmd="bold">B</button><button data-cmd="italic"><em>I</em></button><button data-cmd="underline"><u>U</u></button><button data-cmd="insertUnorderedList">‚Ä¢ List</button><button data-cmd="insertOrderedList">1. List</button><label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üñº Add Image<input type="file" accept="image/*" data-img="journal"></label><label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üé¨ Add Video<input type="file" accept="video/*" data-vid="journal"></label></div><div id="jBody" class="area" contenteditable="true" spellcheck="false" style="max-height:40vh; overflow-y:auto"></div></div></div>
        <div class="actions"><button class="btn ghost" id="jCancel">Cancel</button><button class="btn primary" id="jSave">Save Entry</button></div>
      </div>
    </div>
  </div>
</div>

<div class="modal" id="vizUploadModal" aria-hidden="true">
  <div class="modal-card" style="width:min(720px,95vw)">
    <h3 style="margin:0 0 10px">Upload Images</h3>
    <div class="modal-grid" style="grid-template-columns:1fr 1fr">
      <div>
        <div class="field"><label class="label">Select Files</label><input id="vizFiles" class="text" type="file" accept="image/*,video/*" multiple/></div>
        <div class="field"><label class="label">Video Link (optional)</label><input id="vizLink" class="text" placeholder="https://..."/></div>
        <div class="field"><label class="label">Name prefix (optional)</label><input id="vizName" class="text" placeholder="e.g. Hogwarts_"/></div>
      </div>
      <div>
        <div class="field"><label class="label">Associate to Portal</label><select id="vizPortalSel" class="text"><option value="-1">Unassigned</option></select></div>
        <div class="field"><label class="label">Tags (comma-separated)</label><input id="vizTagsInput" class="text" placeholder="e.g. castle, night, outfit"/></div>
      </div>
    </div>
    <div class="actions"><button class="btn ghost" id="vizCancel">Cancel</button><button class="btn primary" id="vizSave">Save Images</button></div>
  </div>
</div>

<div class="modal" id="lightbox" aria-hidden="true">
  <div class="modal-card" style="width:min(95vw, 1100px); background:var(--bg-0); border-color:var(--bg-1)">
    <div style="display:flex; justify-content:space-between; align-items:center; margin:-8px -8px 8px 0">
      <div id="lbMeta" style="color:var(--muted); font-size:13px"></div>
      <div style="display:flex; gap:8px">
        <button class="btn small" id="lbDelete" style="background:var(--danger); border-color:var(--danger)">Delete</button>
        <button class="btn small" id="lbClose">Close</button>
      </div>
    </div>
    <div style="display:grid; place-items:center; background:var(--bg-0); border:1px solid var(--border); border-radius:12px; padding:8px">
      <img id="lbImg" src="" alt="full" style="max-width:100%; max-height:70vh; border-radius:10px" />
      <video id="lbVideo" controls style="max-width:100%; max-height:70vh; border-radius:10px; display:none"></video>
    </div>
  </div>
</div>

<div class="modal" id="plModal" aria-hidden="true">
  <div class="modal-card" style="width:min(760px,95vw)">
    <h3 id="plModalTitle" style="margin:0 0 10px">New Playlist</h3>
    <div class="modal-grid" style="grid-template-columns:160px 1fr">
      <div style="display:grid; gap:8px; align-content:start">
        <div id="plCoverPrev" class="pl-thumb" style="width:160px; height:160px; border-radius:14px">Cover</div>
        <label class="btn small" style="justify-content:center">Upload Cover<input id="plCoverInput" type="file" accept="image/*" style="display:none"/></label>
      </div>
      <div>
        <div class="field"><label class="label">Name</label><input id="plName" class="text" placeholder="e.g. Hogwarts Sleep Vibes"/></div>
        <div class="field"><label class="label">Linked Portal</label><select id="plPortal" class="text" style="max-width:260px"></select></div>
        <div class="field"><label class="label">Add Track</label>
          <div style="display:grid; grid-template-columns:1fr 1fr 1fr auto; gap:8px; align-items:center">
            <input id="trkTitle" class="text" placeholder="Title"/>
            <input id="trkArtist" class="text" placeholder="Artist"/>
            <input id="trkUrl" class="text" placeholder="URL (YouTube/Spotify/etc.)"/>
            <button class="btn" id="trkAdd">Add</button>
          </div>
        </div>
        <div class="field"><label class="label">Tracks</label><div id="trkList" class="track-list"></div></div>
      </div>
    </div>
    <div class="actions"><button class="btn ghost" id="plCancel">Cancel</button><button class="btn primary" id="plSave">Save Playlist</button></div>
</div>
</div>

<div class="modal" id="scenarioModal" aria-hidden="true">
  <div class="modal-card" style="width:min(560px,95vw)">
    <div style="display:flex; justify-content:space-between; align-items:center; margin:0 0 10px">
      <h3 style="margin:0">New Scenario</h3>
      <select id="scenarioMode" class="text" style="width:auto">
        <option value="free">Freeform</option>
        <option value="prompt">Prompt</option>
      </select>
    </div>
    <div class="field"><label class="label">Title</label><input id="scenarioTitle" class="text"/></div>
    <div class="field" id="scenarioDescField">
      <label class="label">Description</label>
      <div class="rte">
        <div class="rtebar">
          <button data-cmd="bold">B</button>
          <button data-cmd="italic"><em>I</em></button>
          <button data-cmd="insertUnorderedList">‚Ä¢ List</button>
          <button data-cmd="hiliteColor" data-arg="var(--aurora-4)">HL</button>
          <button id="questionToggle" style="margin-left:auto">Show Questions</button>
        </div>
        <div id="scenarioDesc" class="area" contenteditable="true" spellcheck="false" style="min-height:120px"></div>
        <div id="questionContainer" style="display:none; padding:8px">
          <div id="questionPrompt" style="margin-bottom:6px; color:var(--muted)"></div>
          <div style="display:flex; gap:6px">
            <button class="btn small" id="questionInsert">Insert Question</button>
            <button class="btn small ghost" id="questionHide">Hide Questions</button>
          </div>
        </div>
      </div>
    </div>
    <div id="scenarioSectionContainer" style="display:none">
      <div class="field"><label class="label">Setting</label><textarea id="scenarioSetting" class="textarea"></textarea></div>
      <div class="field"><label class="label">Characters</label><textarea id="scenarioCharacters" class="textarea"></textarea></div>
      <div class="field"><label class="label">Conflict</label><textarea id="scenarioConflict" class="textarea"></textarea></div>
    </div>
    <div id="scenarioDraftIndicator" style="display:none; font-size:12px; color:var(--muted); text-align:right; margin:-8px 0 8px">Draft saved</div>
    <div class="field"><label class="label">Collection</label><select id="scenarioCollection" class="text"><option value="">Unassigned</option></select></div>
    <div class="field"><label class="label">Add Category</label><input id="scenarioCategoryInput" class="text" placeholder="Type and press Enter"/></div>
    <div class="field"><label class="label">Categories</label><div id="scenarioCategories" class="tagbar"></div></div>
    <div class="field"><label class="label">Add Tag(s)</label><input id="scenarioTagsInput" class="text" placeholder="Type and press Enter"/></div>
    <div class="field"><label class="label">Tags</label><div id="scenarioTags" class="tagbar"></div></div>
    <div class="field"><label class="label">Add Character</label><input id="scenarioCharsInput" class="text" placeholder="Type and press Enter"/></div>
    <div class="field"><label class="label">Characters</label><div id="scenarioChars" class="tagbar"></div></div>
    <div class="field"><label class="label">Add Location</label><input id="scenarioLocsInput" class="text" placeholder="Type and press Enter"/></div>
    <div class="field"><label class="label">Locations</label><div id="scenarioLocs" class="tagbar"></div></div>
    <div class="field"><label class="label">Images</label><div id="scenarioImageStrip" class="image-strip"></div><button class="btn small" id="scenarioAddImageBtn" style="margin-top:8px">Add Images</button></div>
    <div class="actions">
      <button class="btn ghost" id="scenarioCancel">Cancel</button>
      <button class="btn" id="scenarioSaveDraft">Save as Draft</button>
      <button class="btn primary" id="scenarioPublish">Publish Final</button>
      <button class="btn" id="scenarioHistoryBtn">Version History</button>
    </div>
</div>
</div>

<!-- Scenario Image Picker -->
<div class="modal" id="scenarioImagePicker" aria-hidden="true">
  <div class="modal-card" style="width:min(560px,95vw)">
    <h3 style="margin-top:0">Select Images</h3>
    <div id="scenarioImgGallery" class="pick-gallery"></div>
    <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end">
      <label class="btn small" style="justify-content:center">Upload<input id="scenarioImgFile" type="file" accept="image/*" multiple style="display:none"/></label>
      <button class="btn small ghost" id="scenarioImgCancel">Cancel</button>
      <button class="btn small primary" id="scenarioImgDone">Done</button>
    </div>
  </div>
</div>

<!-- Scenario Version History -->
<div class="modal" id="scenarioHistoryModal" aria-hidden="true">
  <div class="modal-card" style="width:min(400px,90vw)">
    <h3 style="margin-top:0">Version History</h3>
    <div id="scenarioVersionList" style="display:grid; gap:8px; max-height:60vh; overflow-y:auto"></div>
    <div class="actions" style="margin-top:12px">
      <button class="btn ghost" id="scenarioHistoryClose">Close</button>
    </div>
  </div>
</div>

<!-- Dream Entry Modal -->
<div class="modal" id="dreamModal" aria-hidden="true">
  <div class="modal-card" style="width:min(900px,95vw); max-height:90vh; overflow-y:auto">
    <h3 id="dreamModalTitle" style="margin:0 0 16px">New Dream Entry</h3>
    <div class="modal-grid" style="grid-template-columns:1fr 1fr">
      <div>
        <div class="field"><label class="label">Date & Time</label><input id="dreamDate" type="datetime-local" class="text"/></div>
        <div class="field"><label class="label">Dream Title (optional)</label><input id="dreamTitle" class="text" placeholder="e.g. Flying over mountains"/></div>
        <div class="field">
          <label class="label">Lucidity Level</label>
          <select id="dreamLucidity" class="text">
            <option value="normal">Normal Dream</option>
            <option value="semi">Semi-Lucid</option>
            <option value="lucid">Fully Lucid</option>
          </select>
        </div>
        <div class="field">
          <label class="label">Vividness (1-10)</label>
          <input id="dreamVividness" type="range" min="1" max="10" value="5" class="text" style="width:100%"/>
          <div style="display:flex; justify-content:space-between; font-size:12px; color:var(--muted)">
            <span>Vague</span><span id="vividnessValue">5</span><span>Crystal Clear</span>
          </div>
        </div>
        <div class="field">
          <label class="label">Emotions</label>
          <div style="display:flex; gap:6px; flex-wrap:wrap">
            <button type="button" class="emotion-btn" data-emotion="joy">üòä Joy</button>
            <button type="button" class="emotion-btn" data-emotion="fear">üò® Fear</button>
            <button type="button" class="emotion-btn" data-emotion="wonder">ü§© Wonder</button>
            <button type="button" class="emotion-btn" data-emotion="confusion">üòµ Confusion</button>
            <button type="button" class="emotion-btn" data-emotion="excitement">ü§ó Excitement</button>
            <button type="button" class="emotion-btn" data-emotion="calm">üòå Calm</button>
          </div>
        </div>
        <div class="field">
          <label class="label">Dream Tags</label>
          <input id="dreamTagsInput" class="text" placeholder="flying, lucid, nightmare, etc."/>
          <div id="dreamTagsDisplay" style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px"></div>
        </div>
      </div>
      <div>
        <div class="field">
          <label class="label">Dream Description</label>
          <div class="rte">
            <div class="rtebar">
              <button data-cmd="bold">B</button>
              <button data-cmd="italic"><em>I</em></button>
              <button data-cmd="underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList">‚Ä¢ List</button>
              <button data-cmd="insertOrderedList">1. List</button>
            </div>
            <div id="dreamDescription" class="area" contenteditable="true" spellcheck="false" style="min-height:200px"></div>
          </div>
        </div>
        <div class="field">
          <label class="label">Reality Checks Performed</label>
          <div style="display:flex; gap:6px; flex-wrap:wrap">
            <button type="button" class="rc-btn" data-rc="hands">üëã Hands</button>
            <button type="button" class="rc-btn" data-rc="clock">üïê Clock</button>
            <button type="button" class="rc-btn" data-rc="text">üìñ Text</button>
            <button type="button" class="rc-btn" data-rc="mirror">ü™û Mirror</button>
            <button type="button" class="rc-btn" data-rc="nose">üëÉ Nose Pinch</button>
          </div>
        </div>
        <div class="field">
          <label class="label">Goals Attempted</label>
          <select id="dreamGoalsSelect" class="text" multiple style="height:80px">
            <!-- Populated dynamically -->
          </select>
        </div>
      </div>
    </div>
    <div class="actions">
      <button class="btn ghost" id="dreamCancel">Cancel</button>
      <button class="btn primary" id="dreamSave">Save Dream</button>
    </div>
  </div>
</div>

<!-- Goal Modal -->
<div class="modal" id="goalModal" aria-hidden="true">
  <div class="modal-card">
    <h3 id="goalModalTitle" style="margin:0 0 16px">New Lucid Dream Goal</h3>
    <div class="field"><label class="label">Goal Title</label><input id="goalTitle" class="text" placeholder="e.g. Fly to the moon"/></div>
    <div class="field">
      <label class="label">Category</label>
      <select id="goalCategory" class="text">
        <option value="exploration">Exploration</option>
        <option value="flying">Flying</option>
        <option value="meeting">Meeting Someone</option>
        <option value="transformation">Transformation</option>
        <option value="skill">Skill Practice</option>
        <option value="healing">Healing</option>
        <option value="creativity">Creativity</option>
        <option value="other">Other</option>
      </select>
    </div>
    <div class="field"><label class="label">Description</label><textarea id="goalDescription" class="textarea" placeholder="Detailed description of what you want to achieve..."></textarea></div>
    <div class="field">
      <label class="label">Difficulty</label>
      <select id="goalDifficulty" class="text">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
        <option value="expert">Expert</option>
      </select>
    </div>
    <div class="actions">
      <button class="btn ghost" id="goalCancel">Cancel</button>
      <button class="btn primary" id="goalSave">Save Goal</button>
    </div>
  </div>
</div>

<!-- Technique Modal -->
<div class="modal" id="techniqueModal" aria-hidden="true">
  <div class="modal-card">
    <h3 id="techniqueModalTitle" style="margin:0 0 16px">Add Technique</h3>
    <div class="field"><label class="label">Technique Name</label><input id="techniqueName" class="text" placeholder="e.g. WILD, MILD, Reality Checks"/></div>
    <div class="field">
      <label class="label">Type</label>
      <select id="techniqueType" class="text">
        <option value="induction">Dream Induction</option>
        <option value="lucidity">Lucidity Trigger</option>
        <option value="control">Dream Control</option>
        <option value="recall">Dream Recall</option>
        <option value="stabilization">Dream Stabilization</option>
      </select>
    </div>
    <div class="field"><label class="label">Description</label><textarea id="techniqueDescription" class="textarea" placeholder="How to perform this technique..."></textarea></div>
    <div class="field">
      <label class="label">Your Success Rating (1-5 stars)</label>
      <div id="techniqueRating" class="technique-rating">
        <span class="star" data-rating="1">‚òÖ</span>
        <span class="star" data-rating="2">‚òÖ</span>
        <span class="star" data-rating="3">‚òÖ</span>
        <span class="star" data-rating="4">‚òÖ</span>
        <span class="star" data-rating="5">‚òÖ</span>
      </div>
    </div>
    <div class="field"><label class="label">Notes</label><textarea id="techniqueNotes" class="textarea" placeholder="Personal notes, tips, modifications..."></textarea></div>
    <div class="actions">
      <button class="btn ghost" id="techniqueCancel">Cancel</button>
      <button class="btn primary" id="techniqueSave">Save Technique</button>
    </div>
  </div>
</div>

<!-- Astral Projection Entry Modal -->
<div class="modal" id="projectionModal" aria-hidden="true">
  <div class="modal-card" style="width:min(900px,95vw); max-height:90vh; overflow-y:auto">
    <h3 id="projectionModalTitle" style="margin:0 0 16px">New Projection Entry</h3>
    <div class="modal-grid" style="grid-template-columns:1fr 1fr">
      <div>
        <div class="field"><label class="label">Date & Time</label><input id="projectionDate" type="datetime-local" class="text"/></div>
        <div class="field"><label class="label">Session Title (optional)</label><input id="projectionTitle" class="text" placeholder="e.g. Visited the astral library"/></div>
        <div class="field">
          <label class="label">Experience Type</label>
          <select id="projectionType" class="text">
            <option value="failed">Failed Attempt</option>
            <option value="vibrations">Vibrations Only</option>
            <option value="partial">Partial Projection</option>
            <option value="full">Full Projection</option>
          </select>
        </div>
        <div class="field">
          <label class="label">Clarity (1-10)</label>
          <input id="projectionClarity" type="range" min="1" max="10" value="5" class="text" style="width:100%"/>
          <div style="display:flex; justify-content:space-between; font-size:12px; color:var(--muted)">
            <span>Vague</span><span id="clarityValue">5</span><span>Crystal Clear</span>
          </div>
        </div>
        <div class="field">
          <label class="label">Duration (minutes)</label>
          <input id="projectionDuration" type="number" class="text" placeholder="0" min="0"/>
        </div>
        <div class="field">
          <label class="label">Locations Visited</label>
          <div style="display:flex; gap:6px; flex-wrap:wrap">
            <button type="button" class="location-btn" data-location="home">üè† Home</button>
            <button type="button" class="location-btn" data-location="nature">üå≤ Nature</button>
            <button type="button" class="location-btn" data-location="city">üèôÔ∏è City</button>
            <button type="button" class="location-btn" data-location="space">üåå Space</button>
            <button type="button" class="location-btn" data-location="other-dimension">üåÄ Other Dimension</button>
            <button type="button" class="location-btn" data-location="unknown">‚ùì Unknown</button>
          </div>
        </div>
        <div class="field">
          <label class="label">Projection Tags</label>
          <input id="projectionTagsInput" class="text" placeholder="meditation, rope technique, etc."/>
          <div id="projectionTagsDisplay" style="display:flex; gap:6px; flex-wrap:wrap; margin-top:6px"></div>
        </div>
      </div>
      <div>
        <div class="field">
          <label class="label">Experience Description</label>
          <div class="rte">
            <div class="rtebar">
              <button data-cmd="bold">B</button>
              <button data-cmd="italic"><em>I</em></button>
              <button data-cmd="underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList">‚Ä¢ List</button>
              <button data-cmd="insertOrderedList">1. List</button>
            </div>
            <div id="projectionDescription" class="area" contenteditable="true" spellcheck="false" style="min-height:200px"></div>
          </div>
        </div>
        <div class="field">
          <label class="label">Technique Used</label>
          <select id="projectionTechniqueSelect" class="text">
            <option value="">Select technique...</option>
            <option value="rope">Rope Technique</option>
            <option value="monroe">Monroe Technique</option>
            <option value="wake-back-to-bed">Wake Back to Bed</option>
            <option value="meditation">Meditation</option>
            <option value="visualization">Visualization</option>
            <option value="other">Other</option>
          </select>
        </div>
        <div class="field">
          <label class="label">Goals Attempted</label>
          <select id="projectionGoalsSelect" class="text" multiple style="height:80px">
            <!-- Populated dynamically -->
          </select>
        </div>
        <div class="field">
          <label class="label">Challenges Faced</label>
          <div style="display:flex; gap:6px; flex-wrap:wrap">
            <button type="button" class="emotion-btn" data-challenge="fear">üò∞ Fear</button>
            <button type="button" class="emotion-btn" data-challenge="distraction">ü§Ø Distraction</button>
            <button type="button" class="emotion-btn" data-challenge="physical-discomfort">üò£ Physical Discomfort</button>
            <button type="button" class="emotion-btn" data-challenge="time-pressure">‚è∞ Time Pressure</button>
            <button type="button" class="emotion-btn" data-challenge="doubt">ü§î Doubt</button>
            <button type="button" class="emotion-btn" data-challenge="interruption">üìû Interruption</button>
          </div>
        </div>
      </div>
    </div>
    <div class="actions">
      <button class="btn ghost" id="projectionCancel">Cancel</button>
      <button class="btn primary" id="projectionSave">Save Projection</button>
    </div>
  </div>
</div>

<!-- Astral Goal Modal -->
<div class="modal" id="astralGoalModal" aria-hidden="true">
  <div class="modal-card">
    <h3 id="astralGoalModalTitle" style="margin:0 0 16px">New Astral Projection Goal</h3>
    <div class="field"><label class="label">Goal Title</label><input id="astralGoalTitle" class="text" placeholder="e.g. Visit a specific location"/></div>
    <div class="field">
      <label class="label">Category</label>
      <select id="astralGoalCategory" class="text">
        <option value="exploration">Exploration</option>
        <option value="travel">Astral Travel</option>
        <option value="meeting">Meeting Entities</option>
        <option value="healing">Healing Work</option>
        <option value="learning">Learning/Information</option>
        <option value="verification">Reality Verification</option>
        <option value="skill">Skill Development</option>
        <option value="other">Other</option>
      </select>
    </div>
    <div class="field"><label class="label">Description</label><textarea id="astralGoalDescription" class="textarea" placeholder="Detailed description of what you want to achieve..."></textarea></div>
    <div class="field">
      <label class="label">Difficulty</label>
      <select id="astralGoalDifficulty" class="text">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
        <option value="expert">Expert</option>
      </select>
    </div>
    <div class="actions">
      <button class="btn ghost" id="astralGoalCancel">Cancel</button>
      <button class="btn primary" id="astralGoalSave">Save Goal</button>
    </div>
  </div>
</div>

<!-- Astral Technique Modal -->
<div class="modal" id="astralTechniqueModal" aria-hidden="true">
  <div class="modal-card">
    <h3 id="astralTechniqueModalTitle" style="margin:0 0 16px">Add Astral Projection Technique</h3>
    <div class="field"><label class="label">Technique Name</label><input id="astralTechniqueName" class="text" placeholder="e.g. Rope Technique, Monroe Method"/></div>
    <div class="field">
      <label class="label">Type</label>
      <select id="astralTechniqueType" class="text">
        <option value="exit">Exit Technique</option>
        <option value="induction">Consciousness Induction</option>
        <option value="visualization">Visualization Method</option>
        <option value="meditation">Meditation Based</option>
        <option value="energy">Energy Work</option>
        <option value="preparation">Preparation Technique</option>
      </select>
    </div>
    <div class="field"><label class="label">Description</label><textarea id="astralTechniqueDescription" class="textarea" placeholder="How to perform this technique..."></textarea></div>
    <div class="field">
      <label class="label">Your Success Rating (1-5 stars)</label>
      <div id="astralTechniqueRating" class="technique-rating">
        <span class="star" data-rating="1">‚òÖ</span>
        <span class="star" data-rating="2">‚òÖ</span>
        <span class="star" data-rating="3">‚òÖ</span>
        <span class="star" data-rating="4">‚òÖ</span>
        <span class="star" data-rating="5">‚òÖ</span>
      </div>
    </div>
    <div class="field"><label class="label">Notes</label><textarea id="astralTechniqueNotes" class="textarea" placeholder="Personal notes, tips, modifications..."></textarea></div>
    <div class="actions">
      <button class="btn ghost" id="astralTechniqueCancel">Cancel</button>
      <button class="btn primary" id="astralTechniqueSave">Save Technique</button>
    </div>
  </div>
</div>

<!-- Portal Editor Drawer -->
<div class="drawer" id="portalDrawer" aria-hidden="true">
  <div style="display:grid; grid-template-columns:280px 1fr; height:100%">
    <aside class="sections" style="background:var(--bg-0)">
      <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px">
        <strong>Sections</strong>
        <button class="btn small" id="peClose">Close</button>
      </div>
      <div class="field"><label class="label">Portal Name</label><input id="peName" class="text"/></div>
      <div class="field"><label class="label">Cover</label>
        <div style="display:flex; gap:8px; align-items:center">
          <div id="peCoverPrev" class="portal-circle" style="width:64px;height:64px">IMG</div>
          <label class="btn small" style="justify-content:center">Upload<input id="peCoverInput" type="file" accept="image/*" style="display:none"/></label>
        </div>
      </div>
      <ul id="peSecList" style="list-style:none; padding:0; margin:12px 0; display:grid; gap:6px"></ul>
      <div style="display:flex; gap:6px; margin-top:6px">
        <input id="peNewSec" class="text" placeholder="New section name"/>
        <button class="btn small" id="peAddSec">Add</button>
      </div>
    </aside>
    <section class="editor">
      <div id="peEditors" style="display:grid; gap:18px"></div>
      <div style="position:sticky; bottom:0; padding-top:12px; background:linear-gradient(180deg, transparent, var(--bg-0)); display:flex; gap:8px; justify-content:flex-end">
        <button class="btn ghost" id="peCancel">Discard</button>
        <button class="btn primary" id="peSave">Save Portal</button>
      </div>
    </section>
  </div>
</div>

<script>
  // ===== State =====
  const storeKey='drsb-data-v2';
  const syncKey='drsb-sync';
  // ===== Backup constants =====
  const BACKUP_ROOT_PATH = '/ShiftingClouds/DRScript';
  const APP_STATE_FILE = 'app_state.json';
  const SCENARIOS_FILE = 'scenarios.json';
  const CHARACTERS_FILE = 'characters.json';
  const LOCATIONS_FILE = 'locations.json';
  const MEDIA_INDEX_FILE = 'data/media-index.json';

  const DB_NAME = 'drscript';
  const DB_VERSION = 1;
  const APP_VERSION = 1;

  function openAppDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = e => {
        const db = e.target.result;
        ['scenarios','characters','locations','settings','media','syncMeta'].forEach(store => {
          if(!db.objectStoreNames.contains(store)){
            if(store==='settings' || store==='syncMeta'){
              db.createObjectStore(store,{keyPath:'key'});
            }else{
              db.createObjectStore(store,{keyPath:'id'});
            }
          }
        });
      };
      req.onsuccess = e => resolve(e.target.result);
      req.onerror = e => reject(e.target.error);
    });
  }

  function idbRequest(req){
    return new Promise((res,rej)=>{
      req.onsuccess = () => res(req.result);
      req.onerror = () => rej(req.error);
    });
  }

  async function hashJson(obj){
    const data = new TextEncoder().encode(JSON.stringify(obj||{}));
    const buf = await crypto.subtle.digest('SHA-256', data);
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  async function saveToIndexedDB(data, meta){
    const db = await openAppDB();
    const stores=['scenarios','characters','locations','settings','media','syncMeta'];
    const tx = db.transaction(stores,'readwrite');
    const writeArr = (name, items) => {
      const store = tx.objectStore(name);
      store.clear();
      (items||[]).forEach(item=>store.put(item));
    };
    writeArr('scenarios', data.scenarios);
    writeArr('characters', data.characters);
    writeArr('locations', data.locations);
    const sStore = tx.objectStore('settings');
    sStore.clear();
    Object.entries(data.settings||{}).forEach(([key,value])=>sStore.put({key,value}));
    writeArr('media', data.media);
    tx.objectStore('syncMeta').put({...meta, key:'meta'});
    tx.commit && tx.commit();
    await new Promise((res,rej)=>{tx.oncomplete=()=>res();tx.onerror=()=>rej(tx.error);});
  }

  async function refreshInMemoryStores(){
    const db = await openAppDB();
    const tx = db.transaction(['scenarios','characters','locations','settings','media'],'readonly');
    const getAll = store => idbRequest(store.getAll());
    state.scenarios = await getAll(tx.objectStore('scenarios'));
    state.characters = await getAll(tx.objectStore('characters'));
    state.locations = await getAll(tx.objectStore('locations'));
    const settingsArr = await getAll(tx.objectStore('settings'));
    state.settings = {};
    settingsArr.forEach(({key,value})=>state.settings[key]=value);
    state.media = await getAll(tx.objectStore('media'));
  }

  function recomputeDerivedFields(){
    ensureLibraries();
  }

  function rebuildCaches(){ /* placeholder for tag/timeline caches */ }
  function reconnectAudioBindings(){ /* placeholder for audio bindings */ }
  /*
    Each JSON backup file should include a top-level `schema_version`
    field for migration support.

    Expected folder layout:
      BACKUP_ROOT_PATH/
        app_state.json
        scenarios.json
        characters.json
        locations.json
        media-index.json
        media/
          images/
          videos/
  */
  let state = load();
  let restoreSnapshot = null;
  let conflictLogData = [];
  if(state && !localStorage.getItem(storeKey)) save();
  if(!state) state={
    portals:[],
    waitingRooms:[],
    journal:[],
    playlists:[],
    libraries:[],
    images:[],
    videos:[],
    dreams:[],
    lucidGoals:[],
    techniques:[],
    projections:[], 
    astralGoals:[], 
    astralTechniques:[], 
    sync:{
      provider:null,
      appKey:'',
      accessToken:'',
      refreshToken:'',
      dropboxAccountId:'',
      dropboxRootPath:BACKUP_ROOT_PATH,
      path:'/Apps/DR Script Builder/data.json',
      auto:false,
      intervalMins:5,
      lastSync:0
    }
  };
  
  function ensureLibraries(){
    if(!state.libraries){
      const libId=uid();
      state.libraries=[{id:libId, name:'Main', scenarios:state.scenarios||[], collections:state.collections||[]}];
    }
    state.libraries.forEach(lib=>{
      lib.scenarios ||= [];
      lib.collections ||= [];
      lib.scenarios.forEach(sc=>{
        sc.category ??= [];
        sc.tags ??= [];
        sc.collectionId ??= null;
        if(sc.location && !sc.locations) sc.locations=[sc.location];
        sc.locations ??= [];
        sc.characters ??= [];
        sc.imageIds ??= [];
        delete sc.location;
      });
    });
    delete state.scenarios;
    delete state.collections;
  }
  if(!state.playlists) state.playlists=[];
  ensureLibraries();
  let activeLibraryId;
  function initActiveLibrary(){
    activeLibraryId=localStorage.getItem('activeLibraryId');
    if(!activeLibraryId || !state.libraries.find(l=>l.id===activeLibraryId)){
      activeLibraryId=state.libraries[0]?.id;
      localStorage.setItem('activeLibraryId', activeLibraryId);
    }
  }
  initActiveLibrary();
  if(!state.images) state.images=[];
  if(!state.videos) state.videos=[];
  if(!state.dreams) state.dreams=[];
  if(!state.lucidGoals) state.lucidGoals=[];
  if(!state.techniques) state.techniques=[];
  if(!state.projections) state.projections=[];
  if(!state.astralGoals) state.astralGoals=[];
  if(!state.astralTechniques) state.astralTechniques=[];
  if(!state.sync) state.sync={provider:null, appKey:'', accessToken:'', refreshToken:'', dropboxAccountId:'', dropboxRootPath:BACKUP_ROOT_PATH, path:'/Apps/DR Script Builder/data.json', auto:false, intervalMins:5, lastSync:0};
  state.sync.dropboxAccountId ||= '';
  state.sync.dropboxRootPath ||= BACKUP_ROOT_PATH;
  state.sync.refreshToken ||= '';

  // ===== Utils =====
  const qs = (q)=>document.querySelector(q);
  function save(){
    let quota=false;
    try{
      localStorage.setItem(storeKey, JSON.stringify(state));
    }catch(err){
      if(err?.name==='QuotaExceededError'){
        console.warn('Storage quota exceeded, state not fully saved');
      }else{
        console.error('Save failed', err);
      }
      setSyncStatus('Local save failed: ' + err.message);
      const m = qs('#storageModal');
      if(m){
        m.classList.add('open');
      }else if(typeof alert==='function'){
        alert('Local save failed. Try freeing up storage or checking browser settings.');
      }
      return;
    }
    if(state.sync){
      try{
        localStorage.setItem(syncKey, JSON.stringify({accessToken: state.sync.accessToken, refreshToken: state.sync.refreshToken, provider: state.sync.provider, dropboxAccountId: state.sync.dropboxAccountId, dropboxRootPath: state.sync.dropboxRootPath}));
      }catch(err){
        if(err?.name==='QuotaExceededError'){
          quota=true;
          console.warn('Storage quota exceeded, sync token not saved');
        }
      }
    }
    if(quota){
      setSyncStatus('Warning: storage full - data may not be saved');
    }
    // Auto-sync to Dropbox if connected
    if(state.sync?.accessToken && state.sync?.auto) {
      setTimeout(() => {
        syncPush().catch(err => console.warn('Auto-sync failed:', err));
      }, 100);
    }
  }

  function cleanupStateMedia(){
    (state.images||[]).forEach(img=>{
      if(img.src && !img.path) img.path = img.src;
      if(img.src) delete img.src;
    });
    (state.videos||[]).forEach(vid=>{
      if(vid.src && !vid.path) vid.path = vid.src;
      if(vid.src) delete vid.src;
    });
  }

  cleanupStateMedia();
  save();

  function load(){
    let data=null;
    const v2 = localStorage.getItem(storeKey);
    if (v2) {
      try { data = JSON.parse(v2); } catch { data = null; }
    }
    if(!data){
      const legacy = localStorage.getItem('drsb-data');
      if (legacy) {
        try { data = JSON.parse(legacy); } catch { data = null; }
      }
    }
    const syncRaw = localStorage.getItem(syncKey);
    if(syncRaw){
      try{
        const syncData = JSON.parse(syncRaw);
        data = data || {};
        data.sync = { ...(data.sync||{}), ...syncData };
      }catch{}
    }
    return data;
  }
  function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
  function toLocalInput(iso){ try{ const d=new Date(iso); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`; }catch{ return ''; } }

  let lastFocusedElement = null;
  function closeModal(modal){
    if(!modal) return;
    modal.classList.remove('open');
    lastFocusedElement?.focus();
  }

  document.addEventListener('focusin', (e) => {
    if(!e.target.closest('.modal.open')){
      lastFocusedElement = e.target;
    }
  });

  function getActiveLibrary(){
    return state.libraries.find(l=>l.id===activeLibraryId) || state.libraries[0];
  }

  function renderLibrarySelector(){
    const sel = qs('#librarySelect');
    if(!sel) return;
    sel.innerHTML='';
    state.libraries.forEach(lib=>{
      const opt=document.createElement('option');
      opt.value=lib.id;
      opt.textContent=lib.name;
      if(lib.id===activeLibraryId) opt.selected=true;
      sel.appendChild(opt);
    });
  }

  function setActiveLibrary(id){
    activeLibraryId=id;
    localStorage.setItem('activeLibraryId', id);
    renderLibrarySelector();
    renderCollections();
    populateScenarioCollections();
    filterScenarios();
  }

  renderLibrarySelector();
  qs('#librarySelect')?.addEventListener('change', e=> setActiveLibrary(e.target.value));
  qs('#libraryAdd')?.addEventListener('click', ()=>{
    const name=prompt('Library name?');
    if(!name) return;
    const id=uid();
    state.libraries.push({id, name:name.trim(), scenarios:[], collections:[]});
    save();
    setActiveLibrary(id);
  });
  qs('#libraryDelete')?.addEventListener('click', async ()=>{
    if(state.libraries.length<=1) return;
    if(await askConfirm('Delete this library?')){
      const idx=state.libraries.findIndex(l=>l.id===activeLibraryId);
      if(idx>-1){
        state.libraries.splice(idx,1);
        const newId=state.libraries[0]?.id;
        save();
        setActiveLibrary(newId);
      }
    }
  });

  // ===== Navigation =====
  const views={
    portals:qs('#portals-view'),
    journal:qs('#journal-view'),
    playlists:qs('#playlists-view'),
    visualizers:qs('#visualizers-view'),
    scenarios:qs('#scenarios-view'),
    collections:qs('#collections-view'),
    waiting:qs('#waiting-view'),
    settings:qs('#settings-view'),
    lucid:qs('#lucid-view'),
    astral:qs('#astral-view')
  };
  
  document.querySelectorAll('.nav button').forEach(btn=>{
    btn.addEventListener('click',()=>{
      document.querySelectorAll('.nav button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const view = btn.dataset.view; 
      Object.keys(views).forEach(k=>{ 
        if(views[k]) views[k].hidden = k!==view; 
      });
      if(view==='portals') renderPortals();
      if(view==='journal') renderJournal();
      if(view==='waiting') renderWR();
      if(view==='playlists') renderPlaylists();
      if(view==='visualizers') renderVisualizers();
      if(view==='scenarios') filterScenarios();
      if(view==='collections') renderCollections();
      if(view==='lucid') renderLucidDreaming();
      if(view==='astral') renderAstralProjection();
    });
  });

  // ===== Confirm Modal =====
  function askConfirm(message){
    const modal=qs('#confirmModal'); 
    const txt=qs('#confirmText'); 
    const ok=qs('#confirmOk'); 
    const cancel=qs('#confirmCancel');
    return new Promise((resolve)=>{
      const cleanup=()=>{
        ok.onclick=null;
        cancel.onclick=null;
        closeModal(modal);
        modal.setAttribute('aria-hidden','true');
      };
      txt.textContent=message||'Are you sure?'; 
      modal.classList.add('open'); 
      modal.setAttribute('aria-hidden','false');
      ok.onclick=()=>{ cleanup(); resolve(true); }; 
      cancel.onclick=()=>{ cleanup(); resolve(false); };
    });
  }

  // ===== Portals =====
  const portalGrid=qs('#portalGrid');
  const portalCanvas=qs('#portalCanvas');
  const portalCtx=portalCanvas.getContext('2d');
  const starCanvas=qs('#starfieldCanvas');
  const starCtx=starCanvas.getContext('2d');
  const enterApp = qs('#enterApp');
  let starLayers=[];
  let portalSceneObjs=[];
  let offsetX=0, offsetY=0, scale=1;
  let portalSceneToken = 0;
// Canvas/graphics globals
let dpr = window.devicePixelRatio || 1;
const imageCache = new Map();
let tiltX = 0, tiltY = 0;
let buttonBounds = { left: 0, right: 0, top: 0, bottom: 0 };
function updateButtonBounds(){
  const enterRect = enterApp.getBoundingClientRect();
  const canvasRect = portalCanvas.getBoundingClientRect();
  buttonBounds = {
    left: (enterRect.left - canvasRect.left - offsetX) / scale,
    right: (enterRect.right - canvasRect.left - offsetX) / scale,
    top: (enterRect.top - canvasRect.top - offsetY) / scale,
    bottom: (enterRect.bottom - canvasRect.top - offsetY) / scale
  };
}
window.addEventListener('resize', updateButtonBounds);

  portalCanvas.style.touchAction='none';
  portalCanvas.addEventListener('contextmenu',e=>e.preventDefault());
  const activePointers=new Map();
  let isPanning=false;
  let lastX=0, lastY=0;
  let startPinchDist=0;
  let startScale=1;
  let startMidX=0, startMidY=0;
  let startOffsetX=0, startOffsetY=0;
  let dragMoved=false;
  let dragPortal=null;
  let dragPointerId=null;
  let dragVX=0, dragVY=0;

  portalCanvas.addEventListener('pointerdown',e=>{
    activePointers.set(e.pointerId,e);
    if(activePointers.size===1){
      dragMoved=false;
      lastX=e.clientX;
      lastY=e.clientY;
// Right-click pans; left/middle drag objects in the portal preview
isPanning = (e.button === 2);

if (!isPanning) {
  const rect = portalCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left - offsetX) / scale;
  const y = (e.clientY - rect.top - offsetY) / scale;

  // Pick a nearby portal to interact with
  dragPortal = portalSceneObjs.find(o => Math.hypot(o.x - x, o.y - y) < o.r * 2) || null;
  dragPointerId = dragPortal ? e.pointerId : null;
  if (dragPortal) {
    dragPortal.vx = 0;
    dragPortal.vy = 0;
    dragVX = 0;
    dragVY = 0;
    if (portalCanvas.setPointerCapture) {
      try { portalCanvas.setPointerCapture(e.pointerId); } catch {}
    }
  }
} else {
  dragPortal = null;
  dragPointerId = null;
}

    }else if(activePointers.size===2){
      const [p1,p2]=Array.from(activePointers.values());
      startPinchDist=Math.hypot(p1.clientX-p2.clientX,p1.clientY-p2.clientY);
      startScale=scale;
      startMidX=(p1.clientX+p2.clientX)/2;
      startMidY=(p1.clientY+p2.clientY)/2;
      startOffsetX=offsetX;
      startOffsetY=offsetY;
      isPanning=true;
      dragMoved=true;
    }
    portalCanvas.setPointerCapture(e.pointerId);
  });

  portalCanvas.addEventListener('pointermove',e=>{
    if(!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId,e);
    if(activePointers.size===1){
      const dx=e.clientX-lastX;
      const dy=e.clientY-lastY;
      if(Math.abs(dx)>3 || Math.abs(dy)>3) dragMoved=true;
      if(isPanning){
        offsetX+=dx;
        offsetY+=dy;
      }else if(dragPortal && e.pointerId===dragPointerId){
        dragPortal.cx += dx/scale;
        dragPortal.cy += dy/scale;
        dragPortal.x = dragPortal.cx + Math.cos(dragPortal.angle) * dragPortal.orbitRadius;
        dragPortal.y = dragPortal.cy + Math.sin(dragPortal.angle) * dragPortal.orbitRadius;
        dragVX = dx/scale;
        dragVY = dy/scale;
      }
      lastX=e.clientX;
      lastY=e.clientY;
    }else if(activePointers.size===2){
      const [p1,p2]=Array.from(activePointers.values());
      const dist=Math.hypot(p1.clientX-p2.clientX,p1.clientY-p2.clientY);
      if(startPinchDist){
        scale=startScale*dist/startPinchDist;
        scale=Math.min(5,Math.max(0.2,scale));
      }
      const midX=(p1.clientX+p2.clientX)/2;
      const midY=(p1.clientY+p2.clientY)/2;
      offsetX=startOffsetX+(midX-startMidX);
      offsetY=startOffsetY+(midY-startMidY);
    }
  });

  function endPointer(e){
if (
  e.type === 'pointerup' &&
  !dragMoved &&
  dragPortal &&
  e.pointerId===dragPointerId &&
  ((e.pointerType === 'mouse' && e.button === 0) || e.pointerType === 'touch' || e.pointerType === 'pen')
){
      showPortalSummary(dragPortal.portal);
    }
    activePointers.delete(e.pointerId);
    if(e.pointerId===dragPointerId){
      if (dragPortal) {
        dragPortal.vx = dragVX * 0.1;
        dragPortal.vy = dragVY * 0.1;
      }
      dragPortal=null;
      dragPointerId=null;
    }
    if(activePointers.size===0){
      isPanning=false;
      startPinchDist=0;
    }else if(activePointers.size===1){
      const rem=Array.from(activePointers.values())[0];
      lastX=rem.clientX;
      lastY=rem.clientY;
      isPanning=false;
    }
  }

  portalCanvas.addEventListener('pointerup',endPointer);
  portalCanvas.addEventListener('pointercancel',endPointer);

  portalCanvas.addEventListener('contextmenu', e=> e.preventDefault());

  portalCanvas.addEventListener('wheel',e=>{
    e.preventDefault();
    const factor=e.deltaY<0?1.1:0.9;
    scale*=factor;
    scale=Math.min(5,Math.max(0.2,scale));
  },{passive:false});

  function sizePortalCanvas(){
    const rect = portalCanvas.getBoundingClientRect();
    dpr = window.devicePixelRatio || 1;
    portalCanvas.width = rect.width * dpr;
    portalCanvas.height = rect.height * dpr;
    portalCanvas.style.width = `${rect.width}px`;
    portalCanvas.style.height = `${rect.height}px`;
    portalCtx.setTransform(dpr,0,0,dpr,0,0);
  }

  function sizeStarCanvas(){
    starCanvas.width=starCanvas.clientWidth;
    starCanvas.height=starCanvas.clientHeight;
  }

  function initStarfield(){
    sizeStarCanvas();
    starLayers=[];
    const layers=3;
    for(let l=0;l<layers;l++){
      const count=80*(l+1);
      const layer=[];
      const depth=(l+1)/layers;
      for(let i=0;i<count;i++){
        layer.push({
          x:Math.random()*starCanvas.width,
          y:Math.random()*starCanvas.height,
          size:Math.random()*2+0.5,
          vx:(Math.random()-0.5)*0.2,
          vy:(Math.random()-0.5)*0.2,
          alpha:1-depth*0.5
        });
      }
      starLayers.push(layer);
    }
  }

  function drawStarfield(){
    try {
      starCtx.clearRect(0,0,starCanvas.width,starCanvas.height);
      starLayers.forEach((layer,idx)=>{
        const depth=(idx+1)/starLayers.length;
        const parallax=depth*0.3;
        starCtx.save();
        starCtx.translate((offsetX+tiltX*20)*parallax,(offsetY+tiltY*20)*parallax);
        layer.forEach(star=>{
          star.x+=star.vx*depth;
          star.y+=star.vy*depth;
          star.x=(star.x+starCanvas.width)%starCanvas.width;
          star.y=(star.y+starCanvas.height)%starCanvas.height;
          starCtx.globalAlpha=star.alpha;
          starCtx.fillStyle='#fff';
          starCtx.fillRect(star.x,star.y,star.size,star.size);
        });
        starCtx.restore();
      });
    } finally {
      requestAnimationFrame(drawStarfield);
    }
  }

  window.addEventListener('resize',initStarfield);
  window.addEventListener('deviceorientation',e=>{
    tiltX=(e.gamma||0)/45;
    tiltY=(e.beta||0)/45;
  });

  window.addEventListener('resize',sizePortalCanvas);

  async function renderPortalScene(){
    const token = ++portalSceneToken;
// Ensure the canvas is sized correctly, regardless of which helper exists
(typeof resizePortalCanvas === 'function' ? resizePortalCanvas : sizePortalCanvas)();

// Prepare to track async image loads (used later in renderPortalScene)
const loadPromises = [];

    function getPortalRadius(img, base){
      const maxR = base * 0.08;
      if (!img || !img.naturalWidth || !img.naturalHeight) return maxR;
      return Math.min(Math.min(img.naturalWidth, img.naturalHeight) / 2, maxR);
    }

    portalSceneObjs=(state.portals||[]).map(p=>{
      const base = Math.min(portalCanvas.width, portalCanvas.height) / dpr;
      const src = p.coverImage || p.cover || (p.gallery && p.gallery[0]);
      let img = null;
      if (src) {
        img = imageCache.get(src);
        if (!img) {
          img = new Image();
          imageCache.set(src, img);
          img.src = src;
        }
      }
      const r = p.displayRadius || getPortalRadius(img, base);
      p.displayRadius = r;
      const orbitRadius = r * 2;
      const angle = Math.random() * Math.PI * 2;
      const cx = Math.random() * portalCanvas.width;
      const cy = Math.random() * portalCanvas.height;
      const obj = {
        cx,
        cy,
        angle,
        orbitRadius,
        vx:(Math.random()-0.5)*0.5,
        vy:(Math.random()-0.5)*0.5,
        angVel:(Math.random()-0.5)*0.01,
        r,
        color:`hsl(${Math.random()*360},70%,60%)`,
        texture: img,
        cover: img,
        title: p.title || p.name || 'Portal',
        portal: p,
        x: cx + Math.cos(angle) * orbitRadius,
        y: cy + Math.sin(angle) * orbitRadius
      };

if (img && !img.complete) {
  loadPromises.push(new Promise(res => {
    img.onload = () => res();
    img.onerror = () => { imageCache.delete(src); obj.texture = obj.cover = null; res(); };
  }));
}

      return obj;
    });

    await Promise.all(loadPromises);

    if (token !== portalSceneToken) return;

    function draw(){
      if (token !== portalSceneToken) return;
      portalCtx.setTransform(1,0,0,1,0,0);
      portalCtx.clearRect(0,0,portalCanvas.width,portalCanvas.height);
// Prepare canvas for HiDPI drawing (from main)
portalCtx.save();
portalCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

      portalCtx.translate(offsetX,offsetY);
      portalCtx.scale(scale,scale);
      updateButtonBounds();
      const bounds = buttonBounds;
      portalSceneObjs.forEach(o=>{
// Apply random jitter
o.vx += (Math.random() - 0.5) * 0.02;
o.vy += (Math.random() - 0.5) * 0.02;
o.angVel += (Math.random() - 0.5) * 0.0005;

// Apply friction
o.vx *= 0.99;
o.vy *= 0.99;
o.angVel *= 0.99;

// Update position
o.cx += o.vx;
o.cy += o.vy;
o.angle += o.angVel;

o.x = o.cx + Math.cos(o.angle) * o.orbitRadius;
o.y = o.cy + Math.sin(o.angle) * o.orbitRadius;

// Handle boundary bounces
if (o.x < o.r) { o.x = o.r; o.vx *= -0.5; o.cx = o.x - Math.cos(o.angle) * o.orbitRadius; }
else if (o.x > portalCanvas.width - o.r) { o.x = portalCanvas.width - o.r; o.vx *= -0.5; o.cx = o.x - Math.cos(o.angle) * o.orbitRadius; }

  if (o.y < o.r) { o.y = o.r; o.vy *= -0.5; o.cy = o.y - Math.sin(o.angle) * o.orbitRadius; }
  else if (o.y > portalCanvas.height - o.r) { o.y = portalCanvas.height - o.r; o.vy *= -0.5; o.cy = o.y - Math.sin(o.angle) * o.orbitRadius; }

  // Check collision with enterApp button
  const nearestX = Math.max(bounds.left, Math.min(o.x, bounds.right));
  const nearestY = Math.max(bounds.top, Math.min(o.y, bounds.bottom));
  const dx = o.x - nearestX;
  const dy = o.y - nearestY;
  if (dx * dx + dy * dy < o.r * o.r) {
    const distLeft = Math.abs((o.x + o.r) - bounds.left);
    const distRight = Math.abs(bounds.right - (o.x - o.r));
    const distTop = Math.abs((o.y + o.r) - bounds.top);
    const distBottom = Math.abs(bounds.bottom - (o.y - o.r));
    const minDist = Math.min(distLeft, distRight, distTop, distBottom);
    if (minDist === distLeft) {
      o.x = bounds.left - o.r;
      o.vx *= -0.5;
      o.cx = o.x - Math.cos(o.angle) * o.orbitRadius;
    } else if (minDist === distRight) {
      o.x = bounds.right + o.r;
      o.vx *= -0.5;
      o.cx = o.x - Math.cos(o.angle) * o.orbitRadius;
    } else if (minDist === distTop) {
      o.y = bounds.top - o.r;
      o.vy *= -0.5;
      o.cy = o.y - Math.sin(o.angle) * o.orbitRadius;
    } else {
      o.y = bounds.bottom + o.r;
      o.vy *= -0.5;
      o.cy = o.y - Math.sin(o.angle) * o.orbitRadius;
    }
  }

  // Rendering: drop shadow behind orb
portalCtx.save();
portalCtx.shadowColor = 'rgba(0,0,0,0.5)';
portalCtx.shadowBlur = 10;
portalCtx.shadowOffsetX = 0;
portalCtx.shadowOffsetY = 2;
portalCtx.beginPath();
portalCtx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
portalCtx.fillStyle = 'rgba(0,0,0,0)';
portalCtx.fill();
portalCtx.restore();

// Clip to circular mask for the orb content
portalCtx.save();
portalCtx.beginPath();
portalCtx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
portalCtx.clip();

// Draw image if present (support both properties)
const img = o.cover || o.texture;
if (img) {
  const side = Math.min(img.naturalWidth, img.naturalHeight);
  const sx = (img.naturalWidth - side) / 2;
  const sy = (img.naturalHeight - side) / 2;
  portalCtx.drawImage(img, sx, sy, side, side, o.x - o.r, o.y - o.r, o.r * 2, o.r * 2);
} else {
  // Fallback: soft radial glow
  const g = portalCtx.createRadialGradient(o.x, o.y, o.r * 0.2, o.x, o.y, o.r);
  g.addColorStop(0, 'rgba(255,255,255,0.15)');
  g.addColorStop(1, 'rgba(255,255,255,0.02)');
  portalCtx.fillStyle = g;
  portalCtx.fillRect(o.x - o.r, o.y - o.r, o.r * 2, o.r * 2);
}

portalCtx.restore(); // end circular clip

        // soften edges into background
          const fade=portalCtx.createRadialGradient(o.x,o.y,o.r*0.8,o.x,o.y,o.r);
          fade.addColorStop(0,'rgba(0,0,0,0)');
          fade.addColorStop(1,'rgba(0,0,0,1)');
          portalCtx.globalCompositeOperation='destination-out';
          portalCtx.fillStyle=fade;
          portalCtx.beginPath();
          portalCtx.arc(o.x,o.y,o.r,0,Math.PI*2);
          portalCtx.fill();
          portalCtx.globalCompositeOperation='source-over';

          // outer glow
          portalCtx.save();
          portalCtx.shadowColor='rgba(255,255,255,0.6)';
          portalCtx.shadowBlur=15;
          portalCtx.beginPath();
          portalCtx.arc(o.x,o.y,o.r,0,Math.PI*2);
          portalCtx.strokeStyle='rgba(255,255,255,0.2)';
          portalCtx.lineWidth=2;
          portalCtx.stroke();
          portalCtx.restore();
      });
      portalCtx.restore();
      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  }

  async function renderPortals(){
    portalGrid.innerHTML='';
    // Create tile always first
    const creator=document.createElement('div');
    creator.className='portal-card';
    creator.innerHTML='<div class="portal-circle add" id="addPortal"></div><div class="portal-name">Create Portal</div>';
    portalGrid.appendChild(creator);
    qs('#addPortal').onclick=()=>openCreatePortal();

    (state.portals||[]).forEach((p,idx)=>{
      const card=document.createElement('div'); 
      card.className='portal-card';
      const circle=document.createElement('div'); 
      circle.className='portal-circle';
      if(p.cover){ 
        circle.style.backgroundImage=`url(${p.cover})`; 
      } else { 
        circle.textContent=p.name?.slice(0,10)||'Portal'; 
      }
      circle.title='View portal summary';
      circle.onclick=()=>showPortalSummary(ensurePortalShape(state.portals[idx]));
      const name=document.createElement('div'); 
      name.className='portal-name'; 
      name.textContent=p.name||'Portal';
      name.style.cursor='pointer';
      name.onclick=()=>showPortalSummary(ensurePortalShape(state.portals[idx]));
      const actions=document.createElement('div'); 
      actions.className='portal-actions';
      const edit=document.createElement('button'); 
      edit.className='btn small'; 
      edit.textContent='Edit'; 
      edit.onclick=()=>openEditPortal(idx);
      const del=document.createElement('button'); 
      del.className='btn small'; 
      del.textContent='Delete'; 
      del.onclick=async()=>{
        if(await askConfirm('Delete this portal?')){
          state.portals.splice(idx,1);
          save();
          await renderPortals();
        }
      };
      actions.append(edit, del);
      card.append(circle, name, actions);
      portalGrid.appendChild(card);
    });

    qs('#portalEmpty').style.display = (state.portals||[]).length? 'none' : 'grid';
    await renderPortalScene();
  }

  function showPortalSummary(portal){
    const p=portal;
    if(!p) return;
    const modal=qs('#portalSummaryModal');
    const card=qs('#portalSummaryCard');
    card.innerHTML='';

    const title=document.createElement('h3');
    title.style.margin='0 0 10px';
    title.textContent=p.name||'Portal';
    card.appendChild(title);

    if(p.cover){
      const img=document.createElement('img');
      img.src=p.cover;
      img.alt=p.name||'';
      img.style.width='100%';
      img.style.borderRadius='12px';
      img.style.marginBottom='12px';
      card.appendChild(img);
    }

    const wrap=document.createElement('div');
    wrap.style.display='grid';
    wrap.style.gap='12px';
    (p.order||Object.keys(p.sections||{})).forEach(sec=>{
      const section=document.createElement('section');
      const h=document.createElement('h4');
      h.textContent=sec;
      h.style.margin='8px 0';
      section.appendChild(h);
      const body=document.createElement('div');
      body.innerHTML=p.sections?.[sec]||'';
      section.appendChild(body);
      wrap.appendChild(section);
    });
    card.appendChild(wrap);

    const actions=document.createElement('div');
    actions.className='actions';
    const close=document.createElement('button');
    close.className='btn primary';
    close.textContent='Close';

    // Close modal helper
    const hide=()=>{
      closeModal(modal);
      modal.setAttribute('aria-hidden', 'true');
      document.removeEventListener('keydown', handleKeydown);
    };
    close.onclick=hide;
    actions.appendChild(close);
    card.appendChild(actions);

    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');

    // Focus management
    const focusable=modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    focusable[0]?.focus();

    function handleKeydown(e){
      if(e.key==='Escape') hide();
      if(e.key==='Tab' && focusable.length){
        const first=focusable[0];
        const last=focusable[focusable.length-1];
        if(e.shiftKey && document.activeElement===first){
          e.preventDefault();
          last.focus();
        }else if(!e.shiftKey && document.activeElement===last){
          e.preventDefault();
          first.focus();
        }
      }
    }
    document.addEventListener('keydown', handleKeydown);
  }

  // Create Portal Modal
  const pModal=qs('#portalModal'); 
  const pCoverPrev=qs('#pCoverPreview'); 
  const pCoverInput=qs('#pCoverInput'); 
  const pNameInput=qs('#pNameInput');
  let pEditingIndex=null;

  function resetPortalModal(){ 
    pCoverPrev.style.backgroundImage=''; 
    pCoverPrev.textContent='IMG'; 
    pCoverPrev.dataset.src=''; 
    pNameInput.value=''; 
  }

  qs('#pCancel').onclick=()=>{ closeModal(pModal); pEditingIndex=null; };
  qs('#pCreate').onclick=()=>{
    const name=(pNameInput.value||'').trim()||'Untitled Portal';
    const cover=pCoverPrev.dataset.src||'';
    if(pEditingIndex==null){
      const portal={ id:uid(), name, cover, created:Date.now() };
      state.portals.push(portal);
    } else {
      const p=state.portals[pEditingIndex]; 
      if(p){ p.name=name; p.cover=cover; }
    }
    save(); 
    closeModal(pModal);
    const btn=qs('#pCreate'); 
    if(btn) btn.textContent='Create'; 
    resetPortalModal(); 
    renderPortals();
  };

  pCoverInput.onchange=(e)=>{ 
    const f=e.target.files[0]; 
    if(!f) return; 
    const r=new FileReader(); 
    r.onload=()=>{ 
      pCoverPrev.dataset.src=r.result; 
      pCoverPrev.style.backgroundImage=`url(${r.result})`; 
      pCoverPrev.textContent=''; 
    }; 
    r.readAsDataURL(f); 
  };

  function openCreatePortal(){ 
    pEditingIndex=null; 
    resetPortalModal(); 
    pModal.classList.add('open'); 
    const btn=qs('#pCreate'); 
    if(btn) btn.textContent='Create'; 
    pNameInput.focus(); 
  }

  function openEditPortal(idx){ 
    openPortalEditor(idx); 
  }

  // ===== Waiting Rooms =====
  function renderWR(){
    const grid=qs('#wrGrid'); 
    grid.innerHTML='';
    const add=document.createElement('div'); 
    add.className='wr-card'; 
    add.innerHTML='<div class="wr-thumb new" id="wrCreate"></div><div class="wr-label">Create Waiting Room</div>';
    add.querySelector('#wrCreate').onclick=()=>openWREdit(); 
    grid.appendChild(add);
    
    (state.waitingRooms||[]).forEach((wr)=>{
      const card=document.createElement('div'); 
      card.className='wr-card';
      const thumb=document.createElement('div'); 
      thumb.className='wr-thumb';
      if(wr.image){ 
        thumb.style.backgroundImage=`url(${wr.image})`; 
      } else { 
        thumb.textContent=wr.name||'Waiting Room'; 
      }
      if(wr.default){ 
        const b=document.createElement('div'); 
        b.className='badge'; 
        b.textContent='Default'; 
        thumb.appendChild(b); 
      }
      thumb.onclick=()=>openWREdit(wr);
      const label=document.createElement('div'); 
      label.className='wr-label'; 
      label.textContent=wr.name||'Waiting Room';
      const actions=document.createElement('div'); 
      actions.className='wr-actions';
      const del=document.createElement('button'); 
      del.className='btn small'; 
      del.textContent='Delete'; 
      del.setAttribute('data-wr-del', wr.id);
      del.onclick=async (ev)=>{ 
        ev.preventDefault(); 
        ev.stopPropagation(); 
        if(await askConfirm('Delete this waiting room?')){ 
          const i=state.waitingRooms.findIndex(x=>x.id===wr.id); 
          if(i>-1){ 
            state.waitingRooms.splice(i,1); 
            if(!state.waitingRooms.some(w=>w.default) && state.waitingRooms[0]) 
              state.waitingRooms[0].default=true; 
            save(); 
            renderWR(); 
          }
        } 
      };
      actions.appendChild(del);
      card.append(thumb,label,actions); 
      grid.appendChild(card);
    });
  }

  // WR modal
  const wrModal=qs('#wrModal'); 
  const wrThumbEdit=qs('#wrThumbEdit'); 
  const wrImgInput=qs('#wrImgInput'); 
  const wrName=qs('#wrName'); 
  const wrDefault=qs('#wrDefault'); 
  const wrDesc=qs('#wrDesc'); 
  const wrAff=qs('#wrAff'); 
  const wrChecklist=qs('#wrChecklist'); 
  const wrChecklistItem=qs('#wrChecklistItem');
  let wrEditingId=null;
  
  qs('#wrAddItem').onclick=()=>{ 
    const t=(wrChecklistItem.value||'').trim(); 
    if(!t) return; 
    const li=document.createElement('li'); 
    li.textContent=t; 
    wrChecklist.appendChild(li); 
    wrChecklistItem.value=''; 
  };
  
  wrImgInput.onchange=(e)=>{ 
    const f=e.target.files[0]; 
    if(!f) return; 
    const r=new FileReader(); 
    r.onload=()=>{ 
      wrThumbEdit.style.backgroundImage=`url(${r.result})`; 
      wrThumbEdit.textContent=''; 
      wrThumbEdit.dataset.src=r.result; 
    }; 
    r.readAsDataURL(f); 
  };
  
  qs('#wrCancel').onclick=()=>{ closeModal(wrModal); };
  qs('#wrSave').onclick=()=>{
    const data={ 
      id: wrEditingId||uid(), 
      name:(wrName.value||'').trim()||'Waiting Room', 
      image: wrThumbEdit.dataset.src||'', 
      default: wrDefault.checked, 
      html: wrDesc.innerHTML, 
      affirmations: (wrAff.value||'').split('\n').filter(Boolean), 
      checklist: Array.from(wrChecklist.children).map(li=>li.textContent), 
      timer: (qs('#wrTimer').value||'').trim() 
    };
    const idx=state.waitingRooms.findIndex(w=>w.id===data.id);
    if(idx>-1) state.waitingRooms[idx]=data; 
    else state.waitingRooms.push(data);
    if(data.default){ 
      state.waitingRooms.forEach(w=>{ 
        if(w.id!==data.id) w.default=false; 
      }); 
    }
    save(); 
    closeModal(wrModal);
    renderWR();
  };
  
  function openWREdit(wr){
    const data = wr || { 
      id:null, 
      name:'', 
      image:'', 
      default: !state.waitingRooms.length, 
      html:'', 
      affirmations:[], 
      checklist:[], 
      timer:'' 
    };
    wrEditingId=data.id; 
    wrName.value=data.name||''; 
    wrDefault.checked=!!data.default; 
    wrDesc.innerHTML=data.html||''; 
    wrAff.value=(data.affirmations||[]).join('\n'); 
    wrChecklist.innerHTML=''; 
    (data.checklist||[]).forEach(t=>{ 
      const li=document.createElement('li'); 
      li.textContent=t; 
      wrChecklist.appendChild(li); 
    }); 
    qs('#wrTimer').value=data.timer||''; 
    if(data.image){ 
      wrThumbEdit.style.backgroundImage=`url(${data.image})`; 
      wrThumbEdit.textContent=''; 
      wrThumbEdit.dataset.src=data.image; 
    } else { 
      wrThumbEdit.style.backgroundImage=''; 
      wrThumbEdit.textContent=data.name||'Name'; 
      wrThumbEdit.dataset.src=''; 
    }
    wrModal.classList.add('open');
  }

  // ===== Playlists =====
  const plGrid=qs('#plGrid'); 
  const plSearch=qs('#plSearch'); 
  const plPortalFilter=qs('#plPortalFilter');
  const plModal=qs('#plModal'); 
  const plCoverPrev=qs('#plCoverPrev'); 
  const plCoverInput=qs('#plCoverInput'); 
  const plName=qs('#plName'); 
  const plPortalSel=qs('#plPortal'); 
  const trkTitle=qs('#trkTitle'); 
  const trkArtist=qs('#trkArtist'); 
  const trkUrl=qs('#trkUrl'); 
  const trkAdd=qs('#trkAdd'); 
  const trkList=qs('#trkList');
  let plEditingId=null; 
  let plWorkingTracks=[];

  function renderPlaylists(){
    // filters
    plPortalFilter.innerHTML=''; 
    const optAll=document.createElement('option'); 
    optAll.value=''; 
    optAll.textContent='All portals'; 
    plPortalFilter.appendChild(optAll); 
    (state.portals||[]).forEach((p,i)=>{ 
      const o=document.createElement('option'); 
      o.value=String(i); 
      o.textContent=p.name||`Portal ${i+1}`; 
      plPortalFilter.appendChild(o); 
    });

    plGrid.innerHTML='';
    const add=document.createElement('div'); 
    add.className='pl-card'; 
    add.innerHTML='<div class="pl-thumb new" id="plCreate"></div><div class="pl-label">Create Playlist</div>';
    add.querySelector('#plCreate').onclick=()=>openPLEdit(); 
    plGrid.appendChild(add);

    let items=[...(state.playlists||[])];
    const q=(plSearch.value||'').toLowerCase().trim(); 
    if(q){ 
      items=items.filter(pl=> 
        (pl.name||'').toLowerCase().includes(q) || 
        (pl.tracks||[]).some(t=> 
          (t.title||'').toLowerCase().includes(q) || 
          (t.artist||'').toLowerCase().includes(q)
        )
      ); 
    }
    const pf=plPortalFilter.value||''; 
    if(pf!==''){ 
      const i=parseInt(pf,10); 
      items=items.filter(pl=> (pl.portalIndex??-1)===i); 
    }

    items.forEach(pl=>{
      const card=document.createElement('div'); 
      card.className='pl-card';
      const th=document.createElement('div'); 
      th.className='pl-thumb';
      if(pl.cover){ 
        th.style.backgroundImage=`url(${pl.cover})`; 
      } else { 
        th.textContent=pl.name||'Playlist'; 
      }
      th.onclick=()=>openPLEdit(pl);
      const label=document.createElement('div'); 
      label.className='pl-label'; 
      label.textContent=pl.name||'Playlist';
      const meta=document.createElement('div'); 
      meta.style.cssText='text-align:center; color:var(--faint); font-size:12px'; 
      meta.textContent=`${(pl.tracks||[]).length} track(s)`;
      const actions=document.createElement('div'); 
      actions.style.cssText='display:flex; gap:6px; justify-content:center';
      const del=document.createElement('button'); 
      del.className='btn small'; 
      del.textContent='Delete'; 
      del.onclick=async (ev)=>{ 
        ev.preventDefault(); 
        ev.stopPropagation(); 
        if(await askConfirm('Delete this playlist?')){ 
          const i=state.playlists.findIndex(x=>x.id===pl.id); 
          if(i>-1){ 
            state.playlists.splice(i,1); 
            save(); 
            renderPlaylists(); 
          } 
        } 
      };
      actions.appendChild(del);
      card.append(th,label,meta,actions); 
      plGrid.appendChild(card);
    });

    const hasAny=(state.playlists||[]).length>0; 
    qs('#plEmpty').style.display = hasAny? 'none' : 'grid';
  }

  function resetPLModal(){ 
    plCoverPrev.style.backgroundImage=''; 
    plCoverPrev.textContent='Cover'; 
    plCoverPrev.dataset.src=''; 
    plName.value=''; 
    trkTitle.value=''; 
    trkArtist.value=''; 
    trkUrl.value=''; 
    trkList.innerHTML=''; 
    plPortalSel.innerHTML=''; 
    plWorkingTracks=[]; 
  }

  function openPLEdit(pl){
    plEditingId = pl?.id || null; 
    resetPLModal();
    // portals dropdown
    const none=document.createElement('option'); 
    none.value='-1'; 
    none.textContent='No portal link'; 
    plPortalSel.appendChild(none);
    (state.portals||[]).forEach((p,i)=>{ 
      const o=document.createElement('option'); 
      o.value=String(i); 
      o.textContent=p.name||`Portal ${i+1}`; 
      plPortalSel.appendChild(o); 
    });

    if(pl){
      plName.value=pl.name||''; 
      plPortalSel.value=String(pl.portalIndex ?? -1);
      if(pl.cover){ 
        plCoverPrev.dataset.src=pl.cover; 
        plCoverPrev.style.backgroundImage=`url(${pl.cover})`; 
        plCoverPrev.textContent=''; 
      }
      plWorkingTracks=[...(pl.tracks||[])];
      renderTrackList();
      qs('#plModalTitle').textContent='Edit Playlist';
    } else {
      qs('#plModalTitle').textContent='New Playlist';
      plWorkingTracks=[]; 
      renderTrackList();
      plPortalSel.value='-1';
    }

    plModal.classList.add('open');
  }

  function renderTrackList(){
    trkList.innerHTML='';
    if(!plWorkingTracks.length){ 
      const empty=document.createElement('div'); 
      empty.style.cssText='color:var(--muted); text-align:center; padding:8px'; 
      empty.textContent='No tracks yet'; 
      trkList.appendChild(empty); 
      return; 
    }
    plWorkingTracks.forEach((t,idx)=>{
      const row=document.createElement('div'); 
      row.className='track';
      row.innerHTML=`<div><strong>${(t.title||'Untitled').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</strong><div style="color:var(--faint); font-size:12px">${(t.artist||'').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</div><div style="margin-top:4px; font-size:12px"><a href="${t.url||'#'}" target="_blank" rel="noopener">${(t.url||'').replace(/&/g,'&amp;')}</a></div></div>`;
      const up=document.createElement('button'); 
      up.className='btn small'; 
      up.textContent='‚Üë'; 
      up.title='Move up'; 
      up.onclick=()=>{ 
        if(idx>0){ 
          const tmp=plWorkingTracks[idx-1]; 
          plWorkingTracks[idx-1]=plWorkingTracks[idx]; 
          plWorkingTracks[idx]=tmp; 
          renderTrackList(); 
        } 
      };
      const del=document.createElement('button'); 
      del.className='btn small'; 
      del.textContent='Delete'; 
      del.onclick=()=>{ 
        plWorkingTracks.splice(idx,1); 
        renderTrackList(); 
      };
      row.appendChild(up); 
      row.appendChild(del); 
      trkList.appendChild(row);
    });
  }

  trkAdd.onclick=()=>{ 
    const title=(trkTitle.value||'').trim(); 
    const artist=(trkArtist.value||'').trim(); 
    const url=(trkUrl.value||'').trim(); 
    if(!title && !url){ return; } 
    plWorkingTracks.push({ id:uid(), title, artist, url }); 
    trkTitle.value=''; 
    trkArtist.value=''; 
    trkUrl.value=''; 
    renderTrackList(); 
  };
  
  plCoverInput.onchange=(e)=>{ 
    const f=e.target.files[0]; 
    if(!f) return; 
    const r=new FileReader(); 
    r.onload=()=>{ 
      plCoverPrev.dataset.src=r.result; 
      plCoverPrev.style.backgroundImage=`url(${r.result})`; 
      plCoverPrev.textContent=''; 
    }; 
    r.readAsDataURL(f); 
  };
  
  qs('#plCancel').onclick=()=>{ closeModal(plModal); };
  qs('#plSave').onclick=()=>{
    const data={
      id: plEditingId||uid(),
      name:(plName.value||'').trim()||'Playlist',
      cover: plCoverPrev.dataset.src||'',
      portalIndex: parseInt(plPortalSel.value||'-1',10),
      tracks:[...plWorkingTracks]
    };
    const idx=(state.playlists||[]).findIndex(x=>x.id===data.id);
    if(idx>-1) state.playlists[idx]=data;
    else state.playlists.push(data);
    save();
    closeModal(plModal);
    renderPlaylists();
  };

  plSearch?.addEventListener('input', ()=> renderPlaylists());
  plPortalFilter?.addEventListener('change', ()=> renderPlaylists());

  // ===== Collections =====
  const collectionList=qs('#collectionList');
  const collectionEmpty=qs('#collectionEmpty');

  function renderCollections(){
    collectionList.innerHTML='';
    const lib=getActiveLibrary();
    const cols=lib?.collections||[];
    if(!cols.length){
      collectionEmpty.style.display='grid';
      return;
    }
    collectionEmpty.style.display='none';
    cols.forEach((col, idx)=>{
      const item=document.createElement('div');
      item.className='collection-item';
      const name=document.createElement('span');
      name.textContent=col.title||'Untitled';
      name.onclick=()=>{
        const title=prompt('Collection name', col.title||'');
        if(title){
          col.title=title.trim();
          save();
          renderCollections();
          populateScenarioCollections();
          filterScenarios();
        }
      };
      const actions=document.createElement('div');
      actions.className='collection-actions';
      const up=document.createElement('button');
      up.className='btn small';
      up.textContent='‚Üë';
      up.disabled=idx===0;
      up.onclick=()=>{
        const arr=lib.collections;
        [arr[idx-1], arr[idx]]=[arr[idx], arr[idx-1]];
        save();
        renderCollections();
        filterScenarios();
      };
      const down=document.createElement('button');
      down.className='btn small';
      down.textContent='‚Üì';
      down.disabled=idx===cols.length-1;
      down.onclick=()=>{
        const arr=lib.collections;
        [arr[idx], arr[idx+1]]=[arr[idx+1], arr[idx]];
        save();
        renderCollections();
        filterScenarios();
      };
      const del=document.createElement('button');
      del.className='btn small';
      del.textContent='‚úï';
      del.onclick=async()=>{
        if(await askConfirm('Delete this collection?')){
          const removedId=col.id;
          lib.collections.splice(idx,1);
          (lib.scenarios||[]).forEach(sc=>{ if(sc.collectionId===removedId) sc.collectionId=null; });
          save();
          renderCollections();
          filterScenarios();
          populateScenarioCollections();
        }
      };
      actions.append(up,down,del);
      item.append(name,actions);
      collectionList.appendChild(item);
    });
  }

  qs('#collectionCreate')?.addEventListener('click',()=>{
    const title=prompt('Collection name?');
    if(!title) return;
    const lib=getActiveLibrary();
    if(!lib.collections) lib.collections=[];
    lib.collections.push({id:uid(), title:title.trim()});
    save();
    renderCollections();
    populateScenarioCollections();
  });

  // ===== Scenarios =====
  const scenarioList=qs('#scenarioList');
  const scenarioEmpty=qs('#scenarioEmpty');
  const scenarioModal=qs('#scenarioModal');
  const scenarioModalTitle=scenarioModal?.querySelector('h3');
  const scenarioTitle=qs('#scenarioTitle');
  const scenarioDesc=qs('#scenarioDesc');
  const scenarioTemplateSel=qs('#scenarioTemplate');
  const scenarioCategoryInput=qs('#scenarioCategoryInput');
  const scenarioCategories=qs('#scenarioCategories');
  const scenarioTagsInput=qs('#scenarioTagsInput');
  const scenarioTags=qs('#scenarioTags');
  const scenarioCharsInput=qs('#scenarioCharsInput');
  const scenarioChars=qs('#scenarioChars');
  const scenarioLocsInput=qs('#scenarioLocsInput');
  const scenarioLocs=qs('#scenarioLocs');
  const scenarioTagBar=qs('#scenarioTagBar');
  const scenarioSearch=qs('#scenarioSearch');
  const scenarioFilter=qs('#scenarioFilter');
  const scenarioCollectionSel=qs('#scenarioCollection');
  const scenarioDraftIndicator=qs('#scenarioDraftIndicator');
  const scenarioMode=qs('#scenarioMode');
  const scenarioDescField=qs('#scenarioDescField');
  const scenarioSectionContainer=qs('#scenarioSectionContainer');
  const scenarioSetting=qs('#scenarioSetting');
  const scenarioCharacterText=qs('#scenarioCharacters');
  const scenarioConflict=qs('#scenarioConflict');
  const scCategoryMgr=createTagManager(scenarioCategories, scenarioCategoryInput);
  const scTagMgr=createTagManager(scenarioTags, scenarioTagsInput);
  const scCharMgr=createTagManager(scenarioChars, scenarioCharsInput);
  const scLocMgr=createTagManager(scenarioLocs, scenarioLocsInput);
  const scenarioImageStrip=qs('#scenarioImageStrip');
  const scenarioAddImageBtn=qs('#scenarioAddImageBtn');
  const scenarioImgPicker=qs('#scenarioImagePicker');
  const scenarioImgGallery=qs('#scenarioImgGallery');
  const scenarioImgFile=qs('#scenarioImgFile');
  const scenarioImgCancel=qs('#scenarioImgCancel');
  const scenarioImgDone=qs('#scenarioImgDone');
  const scenarioSaveDraft=qs('#scenarioSaveDraft');
  const scenarioPublish=qs('#scenarioPublish');
  const scenarioHistoryBtn=qs('#scenarioHistoryBtn');
  const scenarioHistoryModal=qs('#scenarioHistoryModal');
  const scenarioVersionList=qs('#scenarioVersionList');
  const scenarioHistoryClose=qs('#scenarioHistoryClose');
  let scImageIds=[];
  const questionToggle=qs('#questionToggle');
  const questionContainer=qs('#questionContainer');
  const questionPromptEl=qs('#questionPrompt');
  const questionInsert=qs('#questionInsert');
  const questionHide=qs('#questionHide');
  const questionPrompts=[
    'Who is present?',
    'Where does this take place?',
    'What is the main conflict?',
    'How do the characters feel?'
  ];
  function renderScenarioImages(){
    if(!scenarioImageStrip) return;
    scenarioImageStrip.innerHTML='';
    scImageIds.forEach(id=>{
      const img=(state.images||[]).find(i=>i.id===id);
      if(!img) return;
      const th=document.createElement('div');
      th.className='image-thumb';
      fetchMediaUrl(img.path||img.src).then(url=>{ th.style.backgroundImage=`url(${url})`; });
      const rm=document.createElement('button');
      rm.className='remove';
      rm.textContent='√ó';
      rm.onclick=e=>{ e.stopPropagation(); scImageIds=scImageIds.filter(x=>x!==id); renderScenarioImages(); saveScenarioDraft(); };
      th.appendChild(rm);
      th.onclick=()=> openLightbox(img.path||img.src, img.name||'', img.id, 'image');
      scenarioImageStrip.appendChild(th);
    });
  }
  function renderScenarioImgGallery(){
    if(!scenarioImgGallery) return;
    scenarioImgGallery.innerHTML='';
    (state.images||[]).forEach(img=>{
      const th=document.createElement('div');
      th.className='pick-thumb';
      th.dataset.id=img.id;
      fetchMediaUrl(img.path||img.src).then(url=>{ th.style.backgroundImage=`url(${url})`; });
      if(scImageIds.includes(img.id)) th.classList.add('selected');
      th.onclick=()=>{ const id=img.id; if(scImageIds.includes(id)){ scImageIds=scImageIds.filter(x=>x!==id); th.classList.remove('selected'); } else { scImageIds.push(id); th.classList.add('selected'); } saveScenarioDraft(); };
      scenarioImgGallery.appendChild(th);
    });
  }
  scenarioAddImageBtn?.addEventListener('click',()=>{ renderScenarioImgGallery(); scenarioImgPicker.classList.add('open'); });
  scenarioImgCancel?.addEventListener('click',()=> closeModal(scenarioImgPicker));
  scenarioImgDone?.addEventListener('click',()=>{ renderScenarioImages(); saveScenarioDraft(); closeModal(scenarioImgPicker); });
  scenarioImgFile?.addEventListener('change',e=>{ const files=Array.from(e.target.files||[]); if(!files.length) return; if(!state.images) state.images=[]; let pending=files.length; files.forEach(f=>{ const r=new FileReader(); r.onload=()=>{ const id=uid(); state.images.push({id, path:r.result, name:f.name||'', tags:[], portalIndex:-1, created:Date.now()}); scImageIds.push(id); if(--pending===0){ save(); renderScenarioImgGallery(); saveScenarioDraft(); } }; r.readAsDataURL(f); }); e.target.value=''; });
  let currentQuestionIndex=0;
  let activeScenarioTagFilters=new Set();
  let currentTemplateId=null;
  let currentScenarioId=null;
  let draftIndicatorTimer=null;
  let suppressDraftSave=false;

  const scenarioTemplates=[
    {id:'setting', name:'Dream Setting', prompt:'Describe the dream setting in vivid detail.'},
    {id:'character', name:'Dream Character', prompt:'Create a profile for a dream character.'},
    {id:'goal', name:'Dream Goal', prompt:'Outline the goal you want to achieve in the dream.'}
  ];

  scenarioTemplates.forEach(t=>{
    const opt=document.createElement('option');
    opt.value=t.id;
    opt.textContent=t.name;
    scenarioTemplateSel?.appendChild(opt);
  });

  questionToggle?.addEventListener('click', ()=>{
    if(!questionContainer||!questionPromptEl) return;
    if(questionContainer.style.display==='none'||!questionContainer.style.display){
      questionContainer.style.display='block';
      questionToggle.textContent='Next Question';
    }else{
      currentQuestionIndex=(currentQuestionIndex+1)%questionPrompts.length;
    }
    questionPromptEl.textContent=questionPrompts[currentQuestionIndex];
  });

  questionInsert?.addEventListener('click', ()=>{
    const q=questionPromptEl?.textContent||'';
    if(!q) return;
    if(!scenarioDesc.textContent.trim()){
      scenarioDesc.textContent=q;
      scenarioDesc.classList.add('question-placeholder');
      const clear=()=>{
        scenarioDesc.textContent='';
        scenarioDesc.classList.remove('question-placeholder');
        scenarioDesc.removeEventListener('focus', clear);
      };
      scenarioDesc.addEventListener('focus', clear, {once:true});
    }else{
      scenarioDesc.innerHTML+=(scenarioDesc.innerHTML?'<br><br>':'')+q;
    }
  });

  function updateScenarioMode(){
    const mode=scenarioMode?.value||'free';
    if(mode==='prompt'){
      scenarioDescField.style.display='none';
      scenarioSectionContainer.style.display='block';
    }else{
      scenarioDescField.style.display='';
      scenarioSectionContainer.style.display='none';
    }
  }
  scenarioMode?.addEventListener('change',()=>{updateScenarioMode(); saveScenarioDraft();});

  questionHide?.addEventListener('click', ()=>{
    questionContainer.style.display='none';
    questionToggle.textContent='Show Questions';
  });

  function scenarioDraftKey(id){
    return `scenarioDraft-${id}`;
  }
  function showScenarioDraftIndicator(text='Draft saved'){
    if(!scenarioDraftIndicator) return;
    scenarioDraftIndicator.textContent=text;
    scenarioDraftIndicator.style.display='block';
    clearTimeout(draftIndicatorTimer);
    draftIndicatorTimer=setTimeout(()=>{
      scenarioDraftIndicator.style.display='none';
    },1500);
  }
  function saveScenarioDraft(){
    if(suppressDraftSave || !currentScenarioId) return;
    const mode=scenarioMode?.value||'free';
    const draft={
      title: scenarioTitle.value||'',
      collectionId: scenarioCollectionSel.value||'',
      categories: scCategoryMgr.getTags ? scCategoryMgr.getTags() : [],
      tags: scTagMgr.getTags ? scTagMgr.getTags() : [],
      characters: scCharMgr.getTags ? scCharMgr.getTags() : [],
      locations: scLocMgr.getTags ? scLocMgr.getTags() : [],
      mode,
      imageIds: scImageIds.slice()
    };
    if(mode==='prompt'){
      draft.sections={
        setting: scenarioSetting.value||'',
        characters: scenarioCharacterText.value||'',
        conflict: scenarioConflict.value||''
      };
    }else{
      draft.content=scenarioDesc.innerHTML||'';
    }
    try{
      localStorage.setItem(scenarioDraftKey(currentScenarioId), JSON.stringify(draft));
      localStorage.setItem('scenarioDraftCurrent', currentScenarioId);
      showScenarioDraftIndicator();
    }catch(err){
      console.warn('Failed to save draft', err);
    }
  }
  function loadScenarioDraft(){
    if(!currentScenarioId) return false;
    const raw=localStorage.getItem(scenarioDraftKey(currentScenarioId));
    if(!raw) return false;
    try{
      const draft=JSON.parse(raw);
      suppressDraftSave=true;
      scenarioTitle.value=draft.title||'';
      scenarioMode.value=draft.mode||'free';
      updateScenarioMode();
      if(draft.mode==='prompt'){
        scenarioSetting.value=draft.sections?.setting||'';
        scenarioCharacterText.value=draft.sections?.characters||'';
        scenarioConflict.value=draft.sections?.conflict||'';
      }else{
        scenarioDesc.innerHTML=draft.content||'';
      }
      scenarioCollectionSel.value=draft.collectionId||'';
      if(draft.categories) scCategoryMgr.setTags?.(draft.categories);
      if(draft.tags) scTagMgr.setTags?.(draft.tags);
      if(draft.characters) scCharMgr.setTags?.(draft.characters);
      if(draft.locations) scLocMgr.setTags?.(draft.locations);
      scImageIds = draft.imageIds || [];
      renderScenarioImages();
      suppressDraftSave=false;
      return true;
    }catch(err){
      suppressDraftSave=false;
      console.warn('Failed to load draft', err);
      return false;
    }
  }
  function clearScenarioDraft(id){
    if(!id) return;
    localStorage.removeItem(scenarioDraftKey(id));
    if(localStorage.getItem('scenarioDraftCurrent')===id){
      localStorage.removeItem('scenarioDraftCurrent');
    }
  }

  function populateScenarioCollections(){
    if(!scenarioCollectionSel) return;
    scenarioCollectionSel.innerHTML='<option value="">Unassigned</option>';
    const lib=getActiveLibrary();
    (lib.collections||[]).forEach(c=>{
      const opt=document.createElement('option');
      opt.value=c.id;
      opt.textContent=c.title;
      scenarioCollectionSel.appendChild(opt);
    });
  }

  function getScenarioFinalContent(sc){
    if(sc?.versions && sc.versions.length){
      const v=[...sc.versions].reverse().find(v=>!v.draft)||sc.versions[sc.versions.length-1];
      return v?.content||'';
    }
    if(sc?.sections){
      return Object.values(sc.sections).join(' ');
    }
    return sc?.content||'';
  }

  function saveScenario(publish){
    const mode=scenarioMode.value;
    const title=(scenarioTitle.value||'').trim();
    let content='';
    let sections=null;
    if(mode==='prompt'){
      sections={
        setting:(scenarioSetting.value||'').trim(),
        characters:(scenarioCharacterText.value||'').trim(),
        conflict:(scenarioConflict.value||'').trim()
      };
      content=Object.values(sections).join('<br>');
    }else{
      content=(scenarioDesc.innerHTML||'').trim();
    }
    if(!title){ scenarioTitle.focus(); return; }
    const lib=getActiveLibrary();
    if(!lib.scenarios) lib.scenarios=[];
    let sc=lib.scenarios.find(s=>s.id===currentScenarioId);
    if(!sc){
      sc={id:currentScenarioId||uid(), versions:[]};
      lib.scenarios.push(sc);
    }
    sc.title=title;
    sc.templateId=currentTemplateId;
    sc.prompt=scenarioTemplates.find(t=>t.id===currentTemplateId)?.prompt||'';
    sc.category=scCategoryMgr.getTags();
    sc.tags=scTagMgr.getTags();
    sc.characters=scCharMgr.getTags();
    sc.locations=scLocMgr.getTags();
    sc.collectionId=scenarioCollectionSel.value||null;
    sc.mode=mode;
    sc.imageIds=scImageIds.slice();
    if(mode==='prompt') sc.sections=sections; else delete sc.sections;
    const version={content, timestamp:Date.now(), draft:!publish};
    sc.versions.push(version);
    save();
    if(publish){
      clearScenarioDraft(sc.id);
      closeModal(scenarioModal);
      currentTemplateId=null;
      currentScenarioId=null;
      scCategoryMgr.clear();
      scTagMgr.clear();
      scCharMgr.clear();
      scLocMgr.clear();
      scenarioCollectionSel.value='';
      scenarioMode.value='free';
      updateScenarioMode();
      scenarioDesc.innerHTML='';
      scenarioSetting.value='';
      scenarioCharacterText.value='';
      scenarioConflict.value='';
      scImageIds=[];
      renderScenarioImages();
      filterScenarios();
    }else{
      if(scenarioDraftIndicator){
        scenarioDraftIndicator.textContent='Draft saved';
        scenarioDraftIndicator.style.display='block';
        setTimeout(()=>{ if(scenarioDraftIndicator) scenarioDraftIndicator.style.display='none'; },1500);
      }
      filterScenarios();
    }
  }

  function editScenario(id){
    const lib=getActiveLibrary();
    const sc=(lib.scenarios||[]).find(s=>s.id===id);
    if(sc) openScenarioEditor(null, sc);
  }

  function openScenarioHistory(){
    const lib=getActiveLibrary();
    const sc=(lib.scenarios||[]).find(s=>s.id===currentScenarioId);
    if(!sc) return;
    if(!scenarioVersionList) return;
    scenarioVersionList.innerHTML='';
    const versions=[...sc.versions||[]].sort((a,b)=>b.timestamp-a.timestamp);
    versions.forEach((v,i)=>{
      const row=document.createElement('div');
      row.style.display='flex';
      row.style.justifyContent='space-between';
      row.style.alignItems='center';
      const label=document.createElement('div');
      label.textContent=new Date(v.timestamp).toLocaleString()+ (v.draft?' (draft)':'');
      const btn=document.createElement('button');
      btn.className='btn small';
      btn.textContent='Restore';
      btn.onclick=()=>{ scenarioDesc.innerHTML=v.content; closeModal(scenarioHistoryModal); };
      row.append(label, btn);
      scenarioVersionList.appendChild(row);
    });
    scenarioHistoryModal?.classList.add('open');
  }

  function openScenarioEditor(templateId=null, sc=null){
    if(scenarioDraftIndicator) scenarioDraftIndicator.style.display='none';
    populateScenarioCollections();
    let restored=false;
    if(scenarioModalTitle) scenarioModalTitle.textContent = sc ? 'Edit Scenario' : 'New Scenario';
    if(sc){
      currentScenarioId=sc.id;
      currentTemplateId=sc.templateId||null;
      scenarioTitle.value=sc.title||'';
      scenarioMode.value=sc.mode||'free';
      updateScenarioMode();
      const latest=(sc.versions&&sc.versions.length)?sc.versions[sc.versions.length-1].content:(sc.content||'');
      if(sc.mode==='prompt'){
        scenarioSetting.value=sc.sections?.setting||'';
        scenarioCharacterText.value=sc.sections?.characters||'';
        scenarioConflict.value=sc.sections?.conflict||'';
      }else{
        scenarioDesc.innerHTML=latest;
      }
      scCategoryMgr.setTags(sc.category||[]);
      scTagMgr.setTags(sc.tags||[]);
      scCharMgr.setTags(sc.characters||[]);
      scLocMgr.setTags(sc.locations||[]);
      scenarioCollectionSel.value=sc.collectionId||'';
      scImageIds=sc.imageIds?sc.imageIds.slice():[];
    }else{
      const existing=localStorage.getItem('scenarioDraftCurrent');
      if(existing && localStorage.getItem(scenarioDraftKey(existing))){
        currentScenarioId=existing;
        restored=loadScenarioDraft();
      }else{
        currentScenarioId=uid();
      }
      currentTemplateId=templateId;
      if(!restored){
        scenarioTitle.value='';
        scenarioMode.value='free';
        updateScenarioMode();
        scenarioDesc.innerHTML=templateId ? (scenarioTemplates.find(t=>t.id===templateId)?.prompt||'') : '';
        scenarioSetting.value='';
        scenarioCharacterText.value='';
        scenarioConflict.value='';
        scCategoryMgr.clear();
        scTagMgr.clear();
        scCharMgr.clear();
        scLocMgr.clear();
        scenarioCollectionSel.value='';
        scImageIds=[];
      }
    }
    renderScenarioImages();
    scenarioModal.classList.add('open');
    scenarioTitle.focus();
  }

  function filterScenarios(){
    const lib=getActiveLibrary();
    let items=lib.scenarios||[];
    const q=(scenarioSearch?.value||'').toLowerCase().trim();
    const f=scenarioFilter?.value||'';
    if(q){
      items=items.filter(sc=>{
        const title=(sc.title||'').toLowerCase();
        const descHtml = sc.sections ? Object.values(sc.sections).join(' ') : getScenarioFinalContent(sc);
        const desc = descHtml.replace(/<[^>]*>/g,'').toLowerCase();
        const tags=(sc.tags||[]).map(t=>t.toLowerCase());
        const locations=(sc.locations||[]).map(l=>l.toLowerCase());
        const characters=(sc.characters||[]).map(c=>c.toLowerCase());
        switch(f){
          case 'tag': return tags.some(t=>t.includes(q));
          case 'location': return locations.some(l=>l.includes(q));
          case 'character': return characters.some(c=>c.includes(q));
          default:
            return title.includes(q) || desc.includes(q) || tags.some(t=>t.includes(q)) ||
              locations.some(l=>l.includes(q)) || characters.some(c=>c.includes(q));
        }
      });
    }
    renderScenarios(items);
  }

  function renderScenarios(items){
    const lib=getActiveLibrary();
    scenarioTagBar.innerHTML='';
    const allTags=Array.from(new Set((lib.scenarios||[]).flatMap(s=>s.tags||[]))).sort((a,b)=>a.localeCompare(b));
    const charCounts={};
    const locCounts={};
    (lib.scenarios||[]).forEach(s=>{
      (s.characters||[]).forEach(c=> charCounts[c]=(charCounts[c]||0)+1);
      (s.locations||[]).forEach(l=> locCounts[l]=(locCounts[l]||0)+1);
    });
    allTags.forEach(t=>{
      const chip=document.createElement('span');
      chip.className='tag';
      chip.textContent=t;
      chip.dataset.tag=t;
      if(activeScenarioTagFilters.has(t)) chip.classList.add('active');
      chip.onclick=()=>{
        if(activeScenarioTagFilters.has(t)) activeScenarioTagFilters.delete(t);
        else activeScenarioTagFilters.add(t);
        filterScenarios();
      };
      scenarioTagBar.appendChild(chip);
    });

    scenarioList.innerHTML='';
    let filtered=items ?? (lib.scenarios||[]);
    if(activeScenarioTagFilters.size){
      filtered=filtered.filter(sc=>{
        const set=new Set(sc.tags||[]);
        for(const t of activeScenarioTagFilters){ if(!set.has(t)) return false; }
        return true;
      });
    }
    if(filtered.length===0){
      scenarioEmpty.textContent = (lib.scenarios||[]).length ? 'No scenarios match your search' : 'No scenarios yet';
      scenarioEmpty.style.display='grid';
      return;
    }
    scenarioEmpty.style.display='none';
    const order=(lib.collections||[]).map(c=>c.id);
    filtered.sort((a,b)=>{
      const ia=order.indexOf(a.collectionId);
      const ib=order.indexOf(b.collectionId);
      return (ia===-1?order.length:ia)-(ib===-1?order.length:ib);
    });
    let current=null;
    filtered.forEach(sc=>{
      const cid=sc.collectionId||'';
      if(cid!==current){
        current=cid;
        const h=document.createElement('h3');
        const col=lib.collections.find(c=>c.id===cid);
        h.textContent=col?.title||'Unassigned';
        h.style.margin='16px 0 8px';
        scenarioList.appendChild(h);
      }
      const card=document.createElement('div');
      card.className='scenario-card';
      const h4=document.createElement('h4');
      h4.textContent=sc.title||'Untitled';
      card.appendChild(h4);
      if(sc.sections){
        const sectionTitles={setting:'Setting', characters:'Characters', conflict:'Conflict'};
        Object.entries(sectionTitles).forEach(([key,label])=>{
          const val=sc.sections[key];
          if(!val) return;
          const sh=document.createElement('h5');
          sh.textContent=label;
          sh.style.margin='6px 0 0';
          const sp=document.createElement('div');
          sp.className='formatted';
          sp.innerHTML=val;
          sp.style.margin='0 0 4px';
          sp.style.color='var(--muted)';
          card.append(sh, sp);
        });
      }else{
        const p=document.createElement('div');
        p.className='formatted';
        p.innerHTML=getScenarioFinalContent(sc);
        p.style.margin='0';
        p.style.color='var(--muted)';
        card.appendChild(p);
      }
      if(sc.imageIds && sc.imageIds.length){
        const strip=document.createElement('div');
        strip.className='image-strip';
        sc.imageIds.forEach(id=>{
          const img=(state.images||[]).find(i=>i.id===id);
          if(!img) return;
          const th=document.createElement('div');
          th.className='image-thumb';
          fetchMediaUrl(img.path||img.src).then(url=>{ th.style.backgroundImage=`url(${url})`; });
          th.onclick=e=>{ e.stopPropagation(); openLightbox(img.path||img.src, img.name||'', img.id, 'image'); };
          strip.appendChild(th);
        });
        card.appendChild(strip);
      }
      const tags=document.createElement('div');
      tags.className='tags';
      tags.style.display='flex';
      tags.style.gap='6px';
      tags.style.flexWrap='wrap';
      (sc.characters||[]).forEach(c=>{
        const chip=document.createElement('span');
        chip.className='tag';
        chip.textContent=c;
        chip.title=`${charCounts[c]||0} scenario${(charCounts[c]||0)===1?'':'s'}`;
        chip.onclick=()=>{ scenarioSearch.value=c; scenarioFilter.value='character'; filterScenarios(); };
        tags.appendChild(chip);
      });
      (sc.locations||[]).forEach(l=>{
        const chip=document.createElement('span');
        chip.className='tag';
        chip.textContent=l;
        chip.title=`${locCounts[l]||0} scenario${(locCounts[l]||0)===1?'':'s'}`;
        chip.onclick=()=>{ scenarioSearch.value=l; scenarioFilter.value='location'; filterScenarios(); };
        tags.appendChild(chip);
      });
      (sc.tags||[]).forEach(t=>{
        const chip=document.createElement('span');
        chip.className='tag';
        chip.textContent=t;
        chip.dataset.tag=t;
        chip.onclick=()=>{
          if(activeScenarioTagFilters.has(t)) activeScenarioTagFilters.delete(t);
          else activeScenarioTagFilters.add(t);
          filterScenarios();
        };
        tags.appendChild(chip);
      });
      const actions=document.createElement('div');
      actions.className='scenario-actions';
      const edit=document.createElement('button');
      edit.className='btn small';
      edit.textContent='Edit';
      edit.onclick=(ev)=>{ ev.preventDefault(); ev.stopPropagation(); editScenario(sc.id); };
      actions.appendChild(edit);
      const del=document.createElement('button');
      del.className='btn small';
      del.textContent='Delete';
      del.onclick=async (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        if(await askConfirm('Delete this scenario?')){
          const i=(lib.scenarios||[]).findIndex(x=>x.id===sc.id);
          if(i>-1){
            lib.scenarios.splice(i,1);
            save();
            filterScenarios();
          }
        }
      };
      actions.appendChild(del);
      card.appendChild(tags);
      card.appendChild(actions);
      scenarioList.appendChild(card);
    });
  }

  qs('#scenarioCreate')?.addEventListener('click',()=>{
    openScenarioEditor();
  });

  scenarioTemplateSel?.addEventListener('change',()=>{
    const id=scenarioTemplateSel.value;
    if(!id) return;
    openScenarioEditor(id);
    scenarioTemplateSel.value='';
  });

  qs('#scenarioCancel')?.addEventListener('click',()=>{
    closeModal(scenarioModal);
    currentTemplateId=null;
    currentScenarioId=null;
    if(scenarioDraftIndicator) scenarioDraftIndicator.style.display='none';
  });
  scenarioSaveDraft?.addEventListener('click',()=> saveScenario(false));
  scenarioPublish?.addEventListener('click',()=> saveScenario(true));
  scenarioHistoryBtn?.addEventListener('click',()=> openScenarioHistory());
  scenarioHistoryClose?.addEventListener('click',()=> closeModal(scenarioHistoryModal));

  scenarioTitle?.addEventListener('input', saveScenarioDraft);
  scenarioDesc?.addEventListener('input', saveScenarioDraft);
  scenarioSetting?.addEventListener('input', saveScenarioDraft);
  scenarioCharacterText?.addEventListener('input', saveScenarioDraft);
  scenarioConflict?.addEventListener('input', saveScenarioDraft);
  scenarioCollectionSel?.addEventListener('change', saveScenarioDraft);
  const scCatObserver=new MutationObserver(saveScenarioDraft);
  const scTagObserver=new MutationObserver(saveScenarioDraft);
  const scCharObserver=new MutationObserver(saveScenarioDraft);
  const scLocObserver=new MutationObserver(saveScenarioDraft);
  if(scenarioCategories) scCatObserver.observe(scenarioCategories,{childList:true});
  if(scenarioTags) scTagObserver.observe(scenarioTags,{childList:true});
  if(scenarioChars) scCharObserver.observe(scenarioChars,{childList:true});
  if(scenarioLocs) scLocObserver.observe(scenarioLocs,{childList:true});

  scenarioSearch?.addEventListener('input', ()=> filterScenarios());
  scenarioFilter?.addEventListener('change', ()=> filterScenarios());

  // RTE shared (image insert)
  document.addEventListener('click',(e)=>{
    const btn=e.target.closest('[data-cmd]'); 
    if(btn){ 
      const area = btn.closest('.rte')?.querySelector('.area');
      if(area) {
        area.focus();
        document.execCommand(btn.getAttribute('data-cmd'), false, btn.getAttribute('data-arg')||null);
      }
    }
  });

  // Handle file input for RTE media insertion
  document.addEventListener('change',(e)=>{
    const upImg=e.target.closest('input[type=file][data-img]');
    const upVid=e.target.closest('input[type=file][data-vid]');
    if(upImg || upVid){
      const up = upImg || upVid;
      const f=e.target.files[0];
      if(!f) return;
      const r=new FileReader();
      r.onload=()=>{
        const rte = up.closest('.rte');
        const area = rte?.querySelector('.area');
        if(area) {
          area.focus();
          const el = document.createElement(upVid ? 'video' : 'img');
          el.src = r.result;
          if(upVid) el.controls = true;
          if(upImg) el.alt = f.name || 'Uploaded image';
          el.style.maxWidth = '100%';
          el.style.borderRadius = '10px';
          el.style.border = '1px solid var(--border)';
          el.style.display = 'block';
          el.style.margin = '8px 0';

          const selection = window.getSelection();
          if(selection && selection.rangeCount > 0 && area.contains(selection.anchorNode)) {
            const range = selection.getRangeAt(0);
            range.deleteContents();
            range.insertNode(el);
            range.collapse(false);
          } else {
            area.appendChild(el);
          }

          up.value = '';
        }
      };
      r.readAsDataURL(f);
    }
  });

  function createTagManager(container, input){
    function addChip(tag){
      const t=String(tag).trim();
      if(!t) return;
      const chip=document.createElement('span');
      chip.className='tag';
      chip.textContent=t;
      chip.dataset.tag=t;
      const x=document.createElement('button');
      x.textContent='‚úï';
      x.className='btn small';
      x.style.marginLeft='6px';
      x.onclick=(ev)=>{ ev.preventDefault(); chip.remove(); };
      chip.appendChild(x);
      container.appendChild(chip);
    }
    input?.addEventListener('keydown',(e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        const v=input.value.trim();
        if(v){
          v.split(',').map(s=>s.trim()).filter(Boolean).forEach(addChip);
          input.value='';
        }
      }
    });
    return {
      add:addChip,
      getTags:()=>Array.from(container.querySelectorAll('.tag')).map(t=>t.dataset.tag),
      setTags(tags){ container.innerHTML=''; (tags||[]).forEach(addChip); },
      clear(){ container.innerHTML=''; if(input) input.value=''; }
    };
  }

  // ===== Journal =====
  const jModal=qs('#journalModal'); 
  const jTitle=qs('#jTitle'); 
  const jDate=qs('#jDate'); 
  const jPortalSel=qs('#jPortal'); 
  const jBody=qs('#jBody'); 
  const jTagsInput=qs('#jTagsInput');
  const jTags=qs('#jTags');
  const jTagMgr=createTagManager(jTags, jTagsInput);
  const jSearch=qs('#jSearch');
  const jSort=qs('#jSort');
  const jPortalFilter2=qs('#jPortalFilter');
  const jTagBar=qs('#jTagBar');
  let currentEntryIndex=null; 
  let activeTagFilters=new Set();

  qs('#newEntry').onclick=()=> openJournalEditor();
  qs('#jCancel').onclick=()=>{ closeModal(jModal); };
  qs('#jSave').onclick=()=>{
    const tags = jTagMgr.getTags();
    const entry={
      id: currentEntryIndex==null? uid() : state.journal[currentEntryIndex].id,
      title: (jTitle.value||'').trim(),
      date: new Date(jDate.value).toISOString(),
      portalIndex: parseInt(jPortalSel.value||'-1',10), 
      html: jBody.innerHTML, 
      text: jBody.textContent||'', 
      tags, 
      updated:Date.now() 
    };
    if(currentEntryIndex==null){ 
      state.journal.unshift(entry); 
    } else { 
      state.journal[currentEntryIndex]=entry; 
    }
    save(); 
    closeModal(jModal);
    renderJournal();
  };
  

  document.addEventListener('click',(ev)=>{
    const edit = ev.target.closest('[data-j-edit]'); 
    if(edit){ 
      const id=edit.getAttribute('data-j-edit'); 
      const idx=state.journal.findIndex(e=>e.id===id); 
      if(idx>-1) openJournalEditor(state.journal[idx], idx); 
      return; 
    }
    const del = ev.target.closest('[data-j-del]'); 
    if(del){ 
      ev.preventDefault(); 
      const id=del.getAttribute('data-j-del'); 
      const idx=state.journal.findIndex(e=>e.id===id); 
      if(idx===-1) return; 
      askConfirm('Delete this entry?').then(ok=>{ 
        if(!ok) return; 
        state.journal.splice(idx,1); 
        save(); 
        renderJournal(); 
      }); 
      return; 
    }
    const tg = ev.target.closest('.entry .tag'); 
    if(tg && tg.dataset.tag){ 
      if(activeTagFilters.has(tg.dataset.tag)) 
        activeTagFilters.delete(tg.dataset.tag); 
      else 
        activeTagFilters.add(tg.dataset.tag); 
      renderJournal(); 
    }
  });

  jSearch.addEventListener('input', ()=> renderJournal());
  jSort.addEventListener('change', ()=> renderJournal());
  jPortalFilter2.addEventListener('change', ()=> renderJournal());

  function openJournalEditor(entry=null, idx=null){
    currentEntryIndex=idx; 
    jModal.classList.add('open');
    // populate portals
    jPortalSel.innerHTML=''; 
    const opt=document.createElement('option'); 
    opt.value='-1'; 
    opt.textContent='No portal link'; 
    jPortalSel.appendChild(opt); 
    (state.portals||[]).forEach((p,i)=>{ 
      const o=document.createElement('option'); 
      o.value=String(i); 
      o.textContent=p.name||`Portal ${i+1}`; 
      jPortalSel.appendChild(o); 
    });
    jTitle.value = entry?.title||''; 
    jDate.value = entry?.date ? toLocalInput(entry.date) : toLocalInput(new Date().toISOString()); 
    jPortalSel.value = String(entry?.portalIndex ?? -1);
    jBody.innerHTML = entry?.html || (entry?.text? entry.text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : '');
    jTagMgr.setTags(entry?.tags||[]);
  }

  function renderJournal(){
    // Filters UI
    jPortalFilter2.innerHTML=''; 
    const all=document.createElement('option'); 
    all.value=''; 
    all.textContent='All portals'; 
    jPortalFilter2.appendChild(all); 
    (state.portals||[]).forEach((p,i)=>{ 
      const o=document.createElement('option'); 
      o.value=String(i); 
      o.textContent=p.name||`Portal ${i+1}`; 
      jPortalFilter2.appendChild(o); 
    });
    jTagBar.innerHTML=''; 
    Array.from(new Set(state.journal.flatMap(e=>e.tags||[]))).sort((a,b)=>a.localeCompare(b)).forEach(t=>{ 
      const chip=document.createElement('span'); 
      chip.className='tag'; 
      chip.textContent=t; 
      chip.dataset.tag=t; 
      if(activeTagFilters.has(t)) chip.classList.add('active'); 
      chip.onclick=()=>{ 
        if(activeTagFilters.has(t)) 
          activeTagFilters.delete(t); 
        else 
          activeTagFilters.add(t); 
        renderJournal(); 
      }; 
      jTagBar.appendChild(chip); 
    });

    let items=[...state.journal];
    const q=(jSearch.value||'').toLowerCase().trim(); 
    if(q){ 
      items=items.filter(en=> 
        (en.title||'').toLowerCase().includes(q) || 
        (en.text||'').toLowerCase().includes(q)
      ); 
    }
    const pf=jPortalFilter2.value||''; 
    if(pf!=='' ){ 
      const i=parseInt(pf,10); 
      items=items.filter(en=> (en.portalIndex??-1)===i); 
    }
    if(activeTagFilters.size){ 
      items=items.filter(en=>{ 
        const set=new Set(en.tags||[]); 
        for(const t of activeTagFilters){ 
          if(!set.has(t)) return false; 
        } 
        return true; 
      }); 
    }
    const sort=jSort.value||'date_desc'; 
    items.sort((a,b)=>{ 
      if(sort==='date_asc') return new Date(a.date)-new Date(b.date); 
      if(sort==='title_asc') return (a.title||'').localeCompare(b.title||''); 
      if(sort==='title_desc') return (b.title||'').localeCompare(a.title||''); 
      return new Date(b.date)-new Date(a.date); 
    });

    const list=qs('#journalList'); 
    list.innerHTML='';
    if(!items.length){ 
      qs('#journalEmpty').style.display='grid'; 
      return; 
    } else { 
      qs('#journalEmpty').style.display='none'; 
    }
    items.forEach(en=>{
      const div=document.createElement('div'); 
      div.className='entry';
      const portalName = (en.portalIndex!=null && state.portals[en.portalIndex]) ? 
        (state.portals[en.portalIndex].name||`Portal ${en.portalIndex+1}`) : '‚Äî';
      div.innerHTML = `<div class="meta"><strong>${(en.title||'(untitled)').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</strong> ‚Ä¢ ${new Date(en.date).toLocaleString()} ‚Ä¢ <span>Portal: ${(portalName||'').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</span></div><div class="content" style="margin:8px 0">${en.html||''}</div><div class="tags">${(en.tags||[]).map(t=>`<span class=\"tag\" data-tag=\"${t}\">${t}</span>`).join(' ')}</div><div class="actions" style="margin-top:10px"><button class="btn small" data-j-edit="${en.id}">Edit</button><button class="btn small" data-j-del="${en.id}">Delete</button></div>`;
      list.appendChild(div);
    });
  }

  // ===== Portal Editor Logic =====
  let peIndex=null;
  const peDrawer=qs('#portalDrawer');
  let peOverlay=null;
  const peName=qs('#peName');
  const peCoverPrev=qs('#peCoverPrev');
  const peCoverInput=qs('#peCoverInput');
  const peSecList=qs('#peSecList');
  const peEditors=qs('#peEditors');
  const peNewSec=qs('#peNewSec');
  const defaultSections=[
    'Overview',
    'Identity',
    'Relationships',
    'World Details',
    'Rules & Safety',
    'Abilities',
    'Items & Resources',
    'Time & Return',
    'Notes'
  ];

  function ensurePortalShape(p){
    if(!p.sections) p.sections={};
    if(!p.order) p.order=[...defaultSections];
    defaultSections.forEach(s=>{ 
      if(!(s in p.sections)) p.sections[s]=''; 
      if(!p.order.includes(s)) p.order.push(s); 
    });
    return p;
  }

    function openPortalEditor(idx){
      lastFocusedElement = document.activeElement;
      peIndex=idx;
      const p = ensurePortalShape(state.portals[idx]);
      peName.value = p.name||'';
      if(p.cover){
        peCoverPrev.dataset.src=p.cover;
        peCoverPrev.style.backgroundImage=`url(${p.cover})`;
        peCoverPrev.textContent='';
      }
      else {
        peCoverPrev.dataset.src='';
        peCoverPrev.style.backgroundImage='';
        peCoverPrev.textContent='IMG';
      }

      renderSectionList(p);
      renderSectionEditors(p);

      peOverlay=document.createElement('div');
      peOverlay.className='drawer-overlay';
      peOverlay.setAttribute('aria-hidden','true');
      peOverlay.addEventListener('click', closePortalEditor);
      document.body.appendChild(peOverlay);

      peDrawer.classList.add('open');
      peDrawer.setAttribute('aria-hidden','false');
      peName.focus();
    }

    function closePortalEditor(){
      peDrawer.classList.remove('open');
      peDrawer.setAttribute('aria-hidden','true');
      peOverlay?.remove();
      peOverlay=null;
      peIndex=null;
      lastFocusedElement?.focus();
    }

  function renderSectionList(p){
    peSecList.innerHTML='';
    p.order.forEach((name,i)=>{
      const li=document.createElement('li');
      li.innerHTML=`<button class="btn small" style="width:100%; justify-content:space-between" data-sec="${name}"><span>${name}</span><span style="opacity:.7">‚Ä∫</span></button>`;
      li.querySelector('button').onclick=()=>{
        const target=peEditors.querySelector(`[data-editor="${CSS.escape(name)}"]`);
        if(target) target.scrollIntoView({behavior:'smooth', block:'start'});
        peSecList.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
        li.querySelector('button').classList.add('active');
      };
      peSecList.appendChild(li);
    });
  }
  
  function renderSectionEditors(p){
    peEditors.innerHTML='';
    p.order.forEach((name)=>{
      const wrap=document.createElement('div');
      wrap.setAttribute('data-editor', name);
      wrap.innerHTML = `
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
          <h3 style="margin:0">${name}</h3>
          <div class="rtebar">
            <button data-cmd="bold">B</button>
            <button data-cmd="italic"><em>I</em></button>
            <button data-cmd="underline"><u>U</u></button>
            <button data-cmd="insertUnorderedList">‚Ä¢ List</button>
            <button data-cmd="insertOrderedList">1. List</button>
            <label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üñº Add Image<input type="file" accept="image/*" data-img="sec-${name}"></label><label class="btn-file" style="background:var(--bg-1); border:1px solid var(--border); padding:6px 8px; border-radius:8px; cursor:pointer">üé¨ Add Video<input type="file" accept="video/*" data-vid="sec-${name}"></label>
          </div>
        </div>
        <div class="rte"><div class="area" contenteditable="true" data-area="${name}"></div></div>
      `;
      peEditors.appendChild(wrap);
      const area = wrap.querySelector('[data-area]');
      area.innerHTML = p.sections[name]||'';
    });
  }

  // Portal editor events
  qs('#peClose').onclick=closePortalEditor; 
  qs('#peCancel').onclick=closePortalEditor;
  peCoverInput.onchange=(e)=>{ 
    const f=e.target.files[0]; 
    if(!f) return; 
    const r=new FileReader(); 
    r.onload=()=>{ 
      peCoverPrev.dataset.src=r.result; 
      peCoverPrev.style.backgroundImage=`url(${r.result})`; 
      peCoverPrev.textContent=''; 
    }; 
    r.readAsDataURL(f); 
  };
  
  qs('#peAddSec').onclick=()=>{ 
    const name=(peNewSec.value||'').trim(); 
    if(!name) return; 
    const p=state.portals[peIndex]; 
    if(!p.order.includes(name)){ 
      p.order.push(name); 
      p.sections[name]=''; 
      renderSectionList(p); 
      renderSectionEditors(p); 
      peNewSec.value=''; 
    } 
  };

  // RTE media insert for portal sections
  document.addEventListener('change',(e)=>{
    const up=e.target.closest('input[type=file][data-img^="sec-"], input[type=file][data-vid^="sec-"]');
    if(up){
      const f=e.target.files[0];
      if(!f) return;
      const r=new FileReader();
      r.onload=()=>{
        const name=(up.getAttribute('data-img')||up.getAttribute('data-vid')).slice(4);
        const area=peEditors.querySelector(`[data-area="${CSS.escape(name)}"]`);
        if(area){
          const el=document.createElement(up.hasAttribute('data-vid')?'video':'img');
          el.src=r.result;
          if(el.tagName==='VIDEO') el.controls=true;
          if(el.tagName==='IMG') el.alt='';
          el.style.maxWidth='100%';
          el.style.borderRadius='10px';
          el.style.border='1px solid var(--border)';
          const sel=window.getSelection();
          if(sel && sel.rangeCount){
            const range=sel.getRangeAt(0);
            range.collapse(false);
            range.insertNode(el);
          } else {
            area.appendChild(el);
          }
        }
        up.value='';
      };
      r.readAsDataURL(f);
    }
  });

  qs('#peSave').onclick=()=>{
    const p=state.portals[peIndex]; 
    if(!p) return;
    p.name = (peName.value||'').trim()||'Untitled Portal';
    p.cover = peCoverPrev.dataset.src||p.cover||'';
    p.sections = p.sections||{};
    p.order = p.order||[];
    peEditors.querySelectorAll('[data-area]').forEach(area=>{ 
      const key=area.getAttribute('data-area'); 
      p.sections[key]=area.innerHTML; 
    });
    save(); 
    renderPortals(); 
    closePortalEditor();
  };

  // ===== Visualizers =====
  const vizContainer=qs('#vizContainer'); 
  const vizEmpty=qs('#vizEmpty'); 
  const vizSearch=qs('#vizSearch'); 
  const vizPortalFilter=qs('#vizPortalFilter'); 
  const vizTagBar=qs('#vizTagBar');
  const vizUploadModal=qs('#vizUploadModal'); 
  const vizUploadBtn=qs('#vizUploadBtn');
  const vizFiles=qs('#vizFiles');
  const vizName=qs('#vizName');
  const vizLink=qs('#vizLink');
  const vizPortalSel=qs('#vizPortalSel');
  const vizTagsInput=qs('#vizTagsInput');
  const lightbox=qs('#lightbox');
  const lbImg=qs('#lbImg');
  const lbVideo=qs('#lbVideo');
  const lbMeta=qs('#lbMeta');
  const lbDelete=qs('#lbDelete');
  qs('#lbClose')?.addEventListener('click',()=> { lbVideo.pause(); closeModal(lightbox); });

  let vizActiveTags=new Set();
  let currentLightboxMediaId=null;
  let currentLightboxType='image';

  const mediaCache=new Map();
  async function fetchMediaUrl(path){
    if(!path) return '';
    if(mediaCache.has(path)) return mediaCache.get(path);
    if(path.startsWith('http') || path.startsWith('data:')){
      mediaCache.set(path, path);
      return path;
    }
    try{
      const blob=await dbxDownload(path);
      const url=URL.createObjectURL(blob);
      mediaCache.set(path, url);
      return url;
    }catch(err){
      console.error('Failed to load media', err);
      return '';
    }
  }

  async function openLightbox(path, meta, mediaId, type){
    lbMeta.textContent=meta||'';
    currentLightboxMediaId=mediaId;
    currentLightboxType=type;
    const src=await fetchMediaUrl(path);
    if(type==='video'){
      lbImg.style.display='none';
      lbVideo.style.display='block';
      lbVideo.src=src;
      lbVideo.play();
    }else{
      lbVideo.pause();
      lbVideo.style.display='none';
      lbImg.style.display='block';
      lbImg.src=src;
    }
    if(lbDelete) {
      lbDelete.style.display = mediaId ? 'inline-flex' : 'none';
    }
    lightbox.classList.add('open');
  }

  qs('#lbDelete')?.addEventListener('click', async ()=>{
    if(!currentLightboxMediaId) return;

    if(await askConfirm(`Delete this ${currentLightboxType}? This cannot be undone.`)){
      const arr = currentLightboxType === 'video' ? (state.videos || []) : (state.images || []);
      const idx = arr.findIndex(m => m.id === currentLightboxMediaId);
      if(idx > -1){
        arr.splice(idx, 1);
        save();
        lbVideo.pause();
        closeModal(lightbox);
        renderVisualizers();
      }
    }
  });

  function scanPortalImages(){
    const derived=[];
    (state.portals||[]).forEach((p,pi)=>{
      if(!p || !p.sections) return;
      Object.values(p.sections).forEach(html=>{
        if(!html) return; 
        const div=document.createElement('div'); 
        div.innerHTML=html; 
        div.querySelectorAll('img').forEach((img,idx)=>{
          const src=img.getAttribute('src');
          if(src){
            derived.push({
              id:`drv_${pi}_${idx}_${Math.random().toString(36).slice(2)}`,
              src,
              name:`Embedded ${idx+1}`,
              portalIndex:pi,
              tags:['embedded'],
              created:0,
              derived:true
            });
          }
        });
        div.querySelectorAll('video, iframe').forEach((med,idx)=>{
          const src=med.getAttribute('src');
          if(src){
            derived.push({
              id:`drv_${pi}_${idx}_${Math.random().toString(36).slice(2)}`,
              src,
              name:`Embedded Video ${idx+1}`,
              portalIndex:pi,
              tags:['embedded'],
              created:0,
              derived:true,
              type:'video',
              tag: med.tagName.toLowerCase()
            });
          }
        });
      });
    });
    return derived;
  }

 function renderVisualizers(){
  if(!vizContainer) return;

  // Rebuild the portal filter
  vizPortalFilter.innerHTML = '';
  const all = document.createElement('option');
  all.value = '';
  all.textContent = 'All portals';
  vizPortalFilter.appendChild(all);
  (state.portals || []).forEach((p, i) => {
    const o = document.createElement('option');
    o.value = String(i);
    o.textContent = p.name || `Portal ${i + 1}`;
    vizPortalFilter.appendChild(o);
  });

  // ==== TAG CHIPS (this was the part that broke) ====
  vizTagBar.innerHTML = '';
  const allTags = Array.from(
    new Set([...(state.images || []), ...(state.videos || [])].flatMap(m => m.tags || []))
  ).sort((a,b) => a.localeCompare(b));
  allTags.forEach((t) => {
    const chip = document.createElement('span');
    chip.className = 'tag';
    chip.textContent = t;
    chip.dataset.tag = t;
    if (vizActiveTags.has(t)) chip.classList.add('active');
    chip.onclick = () => {
      vizActiveTags.has(t) ? vizActiveTags.delete(t) : vizActiveTags.add(t);
      renderVisualizers();
    };
    vizTagBar.appendChild(chip);
  });

  // Gather derived media (from portal editors)
  const derived = scanPortalImages();

  // Filters
  const q = (vizSearch?.value || '').toLowerCase().trim();
  const pf = vizPortalFilter?.value || '';
  const pfIdx = pf === '' ? null : parseInt(pf, 10);

  // Group media by portal
  const byPortal = new Map();
  function addToGroup(rec){
    const key = rec.portalIndex != null ? rec.portalIndex : -1;
    if (!byPortal.has(key)) byPortal.set(key, []);
    byPortal.get(key).push(rec);
  }

  (state.images || []).forEach(img => addToGroup({ ...img, type: 'image' }));
  (state.videos || []).forEach(vid => addToGroup({ ...vid, type: 'video' }));
  // keep type if present for derived (videos come through with type:'video')
  derived.forEach(rec => addToGroup({ ...rec, type: rec.type || 'image' }));

  // Apply filters to each group
  for (const [k, arr] of byPortal.entries()) {
    byPortal.set(k, arr.filter(rec => {
      if (pfIdx !== null && (rec.portalIndex ?? -1) !== pfIdx) return false;
      if (vizActiveTags.size) {
        const set = new Set(rec.tags || []);
        for (const t of vizActiveTags) {
          if (!set.has(t)) return false;
        }
      }
      if (q) {
        const hay = [rec.name || '', ...(rec.tags || [])].join(' ').toLowerCase();
        if (!hay.includes(q)) return false;
      }
      return true;
    }));
  }

  // Render
  vizContainer.innerHTML = '';
  let total = 0;
  const keys = [...byPortal.keys()].sort((a,b) => a - b);
  keys.forEach(key => {
    const items = byPortal.get(key) || [];
    if (!items.length) return;
    total += items.length;

    const grp = document.createElement('div');
    grp.className = 'viz-group';
    const title = key === -1 ? 'Unassigned' : (state.portals[key]?.name || `Portal ${key + 1}`);
    grp.innerHTML = `<h3>${title} ‚Ä¢ ${items.length}</h3>`;

    const grid = document.createElement('div');
    grid.className = 'viz-grid';

    items.forEach(it => {
      const th = document.createElement('div');
      th.className = 'viz-thumb';

      if (it.type === 'video' || it.video) {
        // Support <video> and <iframe> (e.g., YouTube)
        let media;
        if (it.tag === 'iframe') {
          media = document.createElement('iframe');
          media.src = it.src;
          media.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
          media.style.border = '0';
          th.style.cursor = 'default';
          th.onclick = () => window.open(it.src, '_blank'); // keep current UX for iframes
        } else {
          media = document.createElement('video');
          media.controls = true;
          media.muted = true;
          if (it.poster) media.poster = it.poster;
          fetchMediaUrl(it.path || it.src).then(url => { media.src = url; });
          // Use lightbox for local videos
          th.onclick = () => openLightbox(
            it.path || it.src,
            `${title}${it.tags?.length ? ' ‚Ä¢ ' + it.tags.join(', ') : ''}`,
            it.derived ? null : it.id,
            'video'
          );
        }
        media.style.position = 'absolute';
        media.style.inset = '0';
        media.style.width = '100%';
        media.style.height = '100%';
        media.style.objectFit = 'cover';
        th.appendChild(media);
      } else {
        fetchMediaUrl(it.path || it.src).then(url => {
          th.style.backgroundImage = `url(${url})`;
        });
        th.onclick = () => openLightbox(
          it.path || it.src,
          `${title}${it.tags?.length ? ' ‚Ä¢ ' + it.tags.join(', ') : ''}`,
          it.derived ? null : it.id,
          'image'
        );
      }

      const cap = document.createElement('div');
      cap.className = 'cap';
      cap.textContent = it.name
        || (it.derived
            ? ((it.type === 'video' || it.video) ? 'Embedded Video' : 'Embedded')
            : ((it.type === 'video' || it.video) ? 'Video' : 'Image'));
      th.appendChild(cap);

      grid.appendChild(th);
    });

    grp.appendChild(grid);
    vizContainer.appendChild(grp);
  });

  vizEmpty.style.display = total ? 'none' : 'grid';
}

  vizUploadBtn?.addEventListener('click', ()=>{
    vizPortalSel.innerHTML=''; 
    const none=document.createElement('option'); 
    none.value='-1'; 
    none.textContent='Unassigned'; 
    vizPortalSel.appendChild(none); 
    (state.portals||[]).forEach((p,i)=>{
      const o=document.createElement('option');
      o.value=String(i);
      o.textContent=p.name||`Portal ${i+1}`;
      vizPortalSel.appendChild(o);
    });
    if(vizFiles) vizFiles.value='';
    if(vizName) vizName.value='';
    if(vizLink) vizLink.value='';
    if(vizTagsInput) vizTagsInput.value='';
    vizUploadModal.classList.add('open');
  });
  
  qs('#vizCancel')?.addEventListener('click', ()=> closeModal(vizUploadModal));
  qs('#vizSave')?.addEventListener('click', ()=>{
    const files = Array.from(vizFiles.files||[]);
    const link = (vizLink.value||'').trim();
    const prefix=(vizName.value||'').trim();
    const tags=(vizTagsInput.value||'').split(',').map(s=>s.trim()).filter(Boolean);
    const portalIndex=parseInt(vizPortalSel.value||'-1',10);

    if(files.length){
      if(!state.sync?.accessToken){
        alert('Connect Dropbox first to upload media.');
        return;
      }
      let pending=files.length;
      if(!state.images) state.images=[];
      if(!state.videos) state.videos=[];
      files.forEach((f,idx)=>{
        const id=uid();
        const dropboxPath=`/Apps/DR Script Builder/media/${id}_${f.name}`;
        const THRESHOLD = 150 * 1024 * 1024;
        const doUpload = async () => {
          try{
            if(f.size > THRESHOLD){
              await dbxUploadChunked(f, dropboxPath);
            }else{
              await dbxUpload(dropboxPath, f);
            }
          }catch(err){
            console.warn('Standard upload failed, retrying chunked', err);
            await dbxUploadChunked(f, dropboxPath);
          }
        };
        doUpload().then(()=>{
          const base={
            id,
            path:dropboxPath,
            name: prefix? `${prefix}${idx+1}` : (f.name||`file_${idx+1}`),
            tags:[...tags],
            portalIndex: isNaN(portalIndex)? -1 : portalIndex,
            created: Date.now()
          };
          if(f.type.startsWith('video/')){
            state.videos.push({...base, video:true});
          }else{
            state.images.push(base);
          }
        }).catch(err=>{
          console.error('Upload failed', err);
          alert('Upload failed: '+err.message);
        }).finally(()=>{
          if(--pending===0){
            save();
            closeModal(vizUploadModal);
            if(vizFiles) vizFiles.value='';
            if(vizLink) vizLink.value='';
            if(vizName) vizName.value='';
            if(vizTagsInput) vizTagsInput.value='';
            if(vizPortalSel) vizPortalSel.value='-1';
            renderVisualizers();
          }
        });
      });
    } else if(link){
      if(!state.videos) state.videos=[];
      state.videos.push({
        id:uid(),
        path:link,
        name: prefix || link,
        tags:[...tags],
        portalIndex: isNaN(portalIndex)? -1 : portalIndex,
        created: Date.now(),
        link:true,
        video:true
      });
      save();
      closeModal(vizUploadModal);
      if(vizFiles) vizFiles.value='';
      if(vizLink) vizLink.value='';
      if(vizName) vizName.value='';
      if(vizTagsInput) vizTagsInput.value='';
      if(vizPortalSel) vizPortalSel.value='-1';
      renderVisualizers();
    } else {
      closeModal(vizUploadModal);
    }
  });

  vizSearch?.addEventListener('input', ()=> renderVisualizers());
  vizPortalFilter?.addEventListener('change', ()=> renderVisualizers());

  // ===== Lucid Dreaming System =====
  let currentDreamEntry = null;
  let currentGoal = null;
  let currentTechnique = null;
  let activeLucidTab = 'dreams';

  function renderLucidDreaming() {
    initLucidTabs();
    renderActiveTab();
  }

  function initLucidTabs() {
    // Only bind to lucid tabs to avoid conflicts with astral tabs
    const lucidView = qs('#lucid-view');
    if(!lucidView) return;
    
    lucidView.querySelectorAll('.tab-btn').forEach(btn => {
      btn.onclick = () => {
        lucidView.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        activeLucidTab = btn.dataset.tab;
        renderActiveTab();
      };
    });
  }

  function renderActiveTab() {
    document.querySelectorAll('.tab-content').forEach(tab => tab.hidden = true);
    const activeTab = qs(`#${activeLucidTab}-tab`);
    if(activeTab) activeTab.hidden = false;
    
    if(activeLucidTab === 'dreams') renderDreams();
    if(activeLucidTab === 'goals') renderGoals();
    if(activeLucidTab === 'techniques') renderTechniques();
    if(activeLucidTab === 'progress') renderProgress();
  }

  function renderDreams() {
    const list = qs('#dreamList');
    const empty = qs('#dreamEmpty');
    
    if(!list || !empty) return;
    
    if(!state.dreams || state.dreams.length === 0) {
      list.innerHTML = '';
      empty.style.display = 'block';
      return;
    }

    empty.style.display = 'none';
    const sortedDreams = [...state.dreams].sort((a, b) => new Date(b.date) - new Date(a.date));
    
    list.innerHTML = '';
    sortedDreams.forEach(dream => {
      const div = document.createElement('div');
      div.className = 'dream-entry';
      
      const date = new Date(dream.date);
      const dateStr = date.toLocaleDateString();
      const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      const lucidityBadge = dream.lucidity === 'lucid' ? 'lucid' : 
                           dream.lucidity === 'semi' ? 'semi' : 'normal';
      
      div.innerHTML = `
        <div class="dream-header">
          <div class="dream-meta">
            <div class="dream-date" style="font-weight:600">${dream.title || 'Untitled Dream'}</div>
            <div style="font-size:12px; color:var(--muted)">${dateStr} ${timeStr}</div>
            <div class="dream-badges">
              <span class="dream-badge ${lucidityBadge}">${dream.lucidity === 'lucid' ? 'Lucid' : dream.lucidity === 'semi' ? 'Semi-Lucid' : 'Normal'}</span>
              <span class="dream-badge" style="background:rgba(124,108,255,.1); color:var(--accent)">Vividness: ${dream.vividness}/10</span>
              ${dream.emotions?.map(e => `<span class="dream-badge" style="background:rgba(139,92,246,.1)">${e}</span>`).join('') || ''}
            </div>
          </div>
          <div class="journal-actions">
            <button class="btn small" onclick="editDream('${dream.id}')">Edit</button>
            <button class="btn small" onclick="deleteDream('${dream.id}')">Delete</button>
          </div>
        </div>
        <div class="dream-content">${dream.description || 'No description'}</div>
        ${dream.tags?.length ? `<div style="margin-top:8px">${dream.tags.map(tag => `<span class="journal-tag">${tag}</span>`).join(' ')}</div>` : ''}
      `;
      
      list.appendChild(div);
    });
  }

  // Global functions for dream actions
  window.editDream = (id) => {
    const dream = state.dreams.find(d => d.id === id);
    if(dream) openDreamEditor(dream);
  };

  window.deleteDream = async (id) => {
    if(await askConfirm('Delete this dream entry?')) {
      state.dreams = state.dreams.filter(d => d.id !== id);
      save();
      renderDreams();
    }
  };

  function renderGoals() {
    const activeList = qs('#activeGoals');
    const completedList = qs('#completedGoals');
    
    if(!activeList || !completedList) return;
    
    activeList.innerHTML = '';
    completedList.innerHTML = '';
    
    (state.lucidGoals || []).forEach(goal => {
      const div = document.createElement('div');
      div.className = `goal-item ${goal.completed ? 'completed' : ''}`;
      
      div.innerHTML = `
        <div>
          <div style="font-weight:600">${goal.title}</div>
          <div style="font-size:12px; color:var(--muted)">${goal.category} ‚Ä¢ ${goal.difficulty}</div>
        </div>
        <div class="goal-actions">
          ${!goal.completed ? `<button class="btn small" onclick="completeGoal('${goal.id}')">‚úì Complete</button>` : ''}
          <button class="btn small" onclick="editGoal('${goal.id}')">Edit</button>
          <button class="btn small" onclick="deleteGoal('${goal.id}')">Delete</button>
        </div>
      `;
      
      if(goal.completed) {
        completedList.appendChild(div);
      } else {
        activeList.appendChild(div);
      }
    });
    
    if(!activeList.children.length) {
      activeList.innerHTML = '<div class="empty" style="padding:20px; text-align:center; color:var(--muted)">No active goals yet</div>';
    }
    if(!completedList.children.length) {
      completedList.innerHTML = '<div class="empty" style="padding:20px; text-align:center; color:var(--muted)">No completed goals yet</div>';
    }
  }

  // Global goal functions
  window.completeGoal = (id) => {
    const goal = state.lucidGoals.find(g => g.id === id);
    if(goal) {
      goal.completed = true;
      goal.completedDate = new Date().toISOString();
      save();
      renderGoals();
    }
  };

  window.editGoal = (id) => {
    const goal = state.lucidGoals.find(g => g.id === id);
    if(goal) openGoalEditor(goal);
  };

  window.deleteGoal = async (id) => {
    if(await askConfirm('Delete this goal?')) {
      state.lucidGoals = state.lucidGoals.filter(g => g.id !== id);
      save();
      renderGoals();
    }
  };

  function renderTechniques() {
    const list = qs('#techniquesList');
    if(!list) return;
    
    list.innerHTML = '';
    
    (state.techniques || []).forEach(technique => {
      const card = document.createElement('div');
      card.className = 'technique-card';
      
      const stars = Array.from({length: 5}, (_, i) => 
        `<span class="star ${i < technique.rating ? 'filled' : ''}" style="pointer-events:none">‚òÖ</span>`
      ).join('');
      
      card.innerHTML = `
        <h4>${technique.name}</h4>
        <div style="font-size:12px; color:var(--muted); margin-bottom:8px">${technique.type}</div>
        <div class="technique-rating">${stars}</div>
        <div style="margin:8px 0">${technique.description}</div>
        ${technique.notes ? `<div style="font-size:12px; color:var(--muted); border-top:1px solid var(--border); padding-top:8px; margin-top:8px">${technique.notes}</div>` : ''}
        <div style="display:flex; gap:6px; margin-top:12px">
          <button class="btn small" onclick="editTechnique('${technique.id}')">Edit</button>
          <button class="btn small" onclick="deleteTechnique('${technique.id}')">Delete</button>
        </div>
      `;
      
      list.appendChild(card);
    });
    
    if(!list.children.length) {
      list.innerHTML = '<div class="empty">No techniques added yet</div>';
    }
  }

  // Global technique functions  
  window.editTechnique = (id) => {
    const technique = state.techniques.find(t => t.id === id);
    if(technique) openTechniqueEditor(technique);
  };

  window.deleteTechnique = async (id) => {
    if(await askConfirm('Delete this technique?')) {
      state.techniques = state.techniques.filter(t => t.id !== id);
      save();
      renderTechniques();
    }
  };

  function renderProgress() {
    const dreams = state.dreams || [];
    
    const recallRate = Math.min(dreams.length * 10, 100);
    const lucidDreams = dreams.filter(d => d.lucidity === 'lucid' || d.lucidity === 'semi');
    const lucidityRate = dreams.length ? Math.round((lucidDreams.length / dreams.length) * 100) : 0;
    const completedGoals = (state.lucidGoals || []).filter(g => g.completed).length;
    
    const recallEl = qs('#recallRate');
    const lucidityEl = qs('#lucidityRate');
    const goalsEl = qs('#goalsAchieved');
    const freqEl = qs('#dreamFreq');
    
    if(recallEl) recallEl.textContent = `${recallRate}%`;
    if(lucidityEl) lucidityEl.textContent = `${lucidityRate}%`;
    if(goalsEl) goalsEl.textContent = completedGoals.toString();
    if(freqEl) freqEl.textContent = (dreams.length / 4.3).toFixed(1);
  }

  // Dream modal handlers
  qs('#newDream')?.addEventListener('click', () => openDreamEditor());
  qs('#newGoal')?.addEventListener('click', () => openGoalEditor());
  qs('#newTechnique')?.addEventListener('click', () => openTechniqueEditor());

  function openDreamEditor(dream = null) {
    currentDreamEntry = dream;
    const modal = qs('#dreamModal');
    
    qs('#dreamTitle').value = dream?.title || '';
    qs('#dreamDate').value = dream?.date ? toLocalInput(dream.date) : toLocalInput(new Date().toISOString());
    qs('#dreamLucidity').value = dream?.lucidity || 'normal';
    qs('#dreamVividness').value = dream?.vividness || 5;
    qs('#vividnessValue').textContent = dream?.vividness || 5;
    qs('#dreamDescription').innerHTML = dream?.description || '';
    qs('#dreamTagsInput').value = (dream?.tags || []).join(', ');
    
    // Clear emotion/RC buttons
    document.querySelectorAll('.emotion-btn, .rc-btn').forEach(btn => btn.classList.remove('active'));
    
    modal.classList.add('open');
  }

  function openGoalEditor(goal = null) {
    currentGoal = goal;
    const modal = qs('#goalModal');
    
    qs('#goalTitle').value = goal?.title || '';
    qs('#goalCategory').value = goal?.category || 'exploration';
    qs('#goalDescription').value = goal?.description || '';
    qs('#goalDifficulty').value = goal?.difficulty || 'medium';
    
    modal.classList.add('open');
  }

  function openTechniqueEditor(technique = null) {
    currentTechnique = technique;
    const modal = qs('#techniqueModal');
    
    qs('#techniqueName').value = technique?.name || '';
    qs('#techniqueType').value = technique?.type || 'induction';
    qs('#techniqueDescription').value = technique?.description || '';
    qs('#techniqueNotes').value = technique?.notes || '';
    
    // Set star rating
    const stars = modal.querySelectorAll('.star');
    stars.forEach((star, i) => {
      star.classList.toggle('filled', i < (technique?.rating || 0));
    });
    
    modal.classList.add('open');
  }

  // Modal save handlers
  qs('#dreamSave')?.addEventListener('click', () => {
    const dreamData = {
      id: currentDreamEntry?.id || uid(),
      title: qs('#dreamTitle').value.trim(),
      date: new Date(qs('#dreamDate').value).toISOString(),
      lucidity: qs('#dreamLucidity').value,
      vividness: parseInt(qs('#dreamVividness').value),
      description: qs('#dreamDescription').innerHTML,
      tags: qs('#dreamTagsInput').value.split(',').map(t => t.trim()).filter(Boolean),
      emotions: Array.from(document.querySelectorAll('.emotion-btn.active')).map(btn => btn.dataset.emotion),
      realityChecks: Array.from(document.querySelectorAll('.rc-btn.active')).map(btn => btn.dataset.rc),
      created: currentDreamEntry?.created || Date.now()
    };
    
    if(currentDreamEntry) {
      const idx = state.dreams.findIndex(d => d.id === currentDreamEntry.id);
      if(idx > -1) state.dreams[idx] = dreamData;
    } else {
      if(!state.dreams) state.dreams = [];
      state.dreams.push(dreamData);
    }
    
    save();
    closeModal(qs('#dreamModal'));
    renderDreams();
  });

  qs('#goalSave')?.addEventListener('click', () => {
    const goalData = {
      id: currentGoal?.id || uid(),
      title: qs('#goalTitle').value.trim(),
      category: qs('#goalCategory').value,
      description: qs('#goalDescription').value.trim(),
      difficulty: qs('#goalDifficulty').value,
      completed: currentGoal?.completed || false,
      created: currentGoal?.created || Date.now()
    };
    
    if(currentGoal) {
      const idx = state.lucidGoals.findIndex(g => g.id === currentGoal.id);
      if(idx > -1) state.lucidGoals[idx] = goalData;
    } else {
      if(!state.lucidGoals) state.lucidGoals = [];
      state.lucidGoals.push(goalData);
    }
    
    save();
    closeModal(qs('#goalModal'));
    renderGoals();
  });

  qs('#techniqueSave')?.addEventListener('click', () => {
    const rating = document.querySelectorAll('#techniqueRating .star.filled').length;
    
    const techniqueData = {
      id: currentTechnique?.id || uid(),
      name: qs('#techniqueName').value.trim(),
      type: qs('#techniqueType').value,
      description: qs('#techniqueDescription').value.trim(),
      notes: qs('#techniqueNotes').value.trim(),
      rating: rating,
      created: currentTechnique?.created || Date.now()
    };
    
    if(currentTechnique) {
      const idx = state.techniques.findIndex(t => t.id === currentTechnique.id);
      if(idx > -1) state.techniques[idx] = techniqueData;
    } else {
      if(!state.techniques) state.techniques = [];
      state.techniques.push(techniqueData);
    }
    
    save();
    closeModal(qs('#techniqueModal'));
    renderTechniques();
  });

  // Modal cancel handlers
  qs('#dreamCancel')?.addEventListener('click', () => closeModal(qs('#dreamModal')));
  qs('#goalCancel')?.addEventListener('click', () => closeModal(qs('#goalModal')));
  qs('#techniqueCancel')?.addEventListener('click', () => closeModal(qs('#techniqueModal')));

  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') {
      document.querySelectorAll('.modal.open').forEach(m => closeModal(m));
      if(peDrawer.classList.contains('open')) closePortalEditor();
    }
  });

  document.addEventListener('click', (e) => {
    const modal = e.target.closest('.modal.open');
    if(modal && !e.target.closest('.modal-card')) {
      closeModal(modal);
    }
  });

  // Emotion and RC button handlers
  document.addEventListener('click', (e) => {
    if(e.target.matches('.emotion-btn, .rc-btn')) {
      e.target.classList.toggle('active');
    }
  });

  // Star rating handler
  document.addEventListener('click', (e) => {
    if(e.target.matches('#techniqueRating .star')) {
      const rating = parseInt(e.target.dataset.rating);
      const stars = document.querySelectorAll('#techniqueRating .star');
      stars.forEach((star, i) => {
        star.classList.toggle('filled', i < rating);
      });
    }
  });

  // Vividness slider handler
  qs('#dreamVividness')?.addEventListener('input', (e) => {
    qs('#vividnessValue').textContent = e.target.value;
  });

  // ===== Astral Projection System =====
  let currentProjectionEntry = null;
  let currentAstralGoal = null;
  let currentAstralTechnique = null;
  let activeAstralTab = 'projections';

  function renderAstralProjection() {
    initAstralTabs();
    renderActiveAstralTab();
  }

  function initAstralTabs() {
    // Only bind to astral tabs to avoid conflicts with lucid tabs
    const astralView = qs('#astral-view');
    if(!astralView) return;
    
    astralView.querySelectorAll('.tab-btn').forEach(btn => {
      btn.onclick = () => {
        astralView.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        activeAstralTab = btn.dataset.tab;
        renderActiveAstralTab();
      };
    });
  }

  function renderActiveAstralTab() {
    const astralView = qs('#astral-view');
    if(!astralView || astralView.hidden) return;
    
    // Hide all astral tab content
    astralView.querySelectorAll('.tab-content').forEach(tab => tab.hidden = true);
    
    // Show the active tab
    const activeTab = qs(`#${activeAstralTab}-tab`);
    if(activeTab) {
      activeTab.hidden = false;
    } else {
      console.warn('Could not find astral tab:', activeAstralTab);
    }
    
    // Render the appropriate content
    if(activeAstralTab === 'projections') renderProjections();
    if(activeAstralTab === 'astral-goals') renderAstralGoals();
    if(activeAstralTab === 'astral-techniques') renderAstralTechniques();
    if(activeAstralTab === 'astral-progress') renderAstralProgress();
  }

  function renderProjections() {
    const list = qs('#projectionList');
    const empty = qs('#projectionEmpty');
    
    if(!list || !empty) return;
    
    if(!state.projections || state.projections.length === 0) {
      list.innerHTML = '';
      empty.style.display = 'block';
      return;
    }

    empty.style.display = 'none';
    const sortedProjections = [...state.projections].sort((a, b) => new Date(b.date) - new Date(a.date));
    
    list.innerHTML = '';
    sortedProjections.forEach(projection => {
      const div = document.createElement('div');
      div.className = 'projection-entry';
      
      const date = new Date(projection.date);
      const dateStr = date.toLocaleDateString();
      const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      const typeBadge = projection.type || 'failed';
      const typeLabel = {
        'full': 'Full Projection',
        'partial': 'Partial Projection', 
        'vibrations': 'Vibrations Only',
        'failed': 'Failed Attempt'
      }[typeBadge] || 'Unknown';
      
      div.innerHTML = `
        <div class="projection-header">
          <div class="projection-meta">
            <div class="dream-date" style="font-weight:600">${projection.title || 'Untitled Session'}</div>
            <div style="font-size:12px; color:var(--muted)">${dateStr} ${timeStr}</div>
            <div class="projection-badges">
              <span class="projection-badge ${typeBadge}">${typeLabel}</span>
              <span class="projection-badge" style="background:rgba(124,108,255,.1); color:var(--accent)">Clarity: ${projection.clarity}/10</span>
              ${projection.duration ? `<span class="projection-badge" style="background:rgba(34,197,94,.1); color:#22c55e">${projection.duration} min</span>` : ''}
              ${projection.locations?.map(l => `<span class="projection-badge" style="background:rgba(99,102,241,.1)">${l}</span>`).join('') || ''}
            </div>
          </div>
          <div class="journal-actions">
            <button class="btn small" onclick="editProjection('${projection.id}')">Edit</button>
            <button class="btn small" onclick="deleteProjection('${projection.id}')">Delete</button>
          </div>
        </div>
        <div class="dream-content">${projection.description || 'No description'}</div>
        ${projection.tags?.length ? `<div style="margin-top:8px">${projection.tags.map(tag => `<span class="journal-tag">${tag}</span>`).join(' ')}</div>` : ''}
      `;
      
      list.appendChild(div);
    });
  }

  // Global functions for projection actions
  window.editProjection = (id) => {
    const projection = state.projections.find(p => p.id === id);
    if(projection) openProjectionEditor(projection);
  };

  window.deleteProjection = async (id) => {
    if(await askConfirm('Delete this projection entry?')) {
      state.projections = state.projections.filter(p => p.id !== id);
      save();
      renderProjections();
    }
  };

  function renderAstralGoals() {
    const activeList = qs('#activeAstralGoals');
    const completedList = qs('#completedAstralGoals');
    
    if(!activeList || !completedList) return;
    
    activeList.innerHTML = '';
    completedList.innerHTML = '';
    
    (state.astralGoals || []).forEach(goal => {
      const div = document.createElement('div');
      div.className = `goal-item ${goal.completed ? 'completed' : ''}`;
      
      div.innerHTML = `
        <div>
          <div style="font-weight:600">${goal.title}</div>
          <div style="font-size:12px; color:var(--muted)">${goal.category} ‚Ä¢ ${goal.difficulty}</div>
        </div>
        <div class="goal-actions">
          ${!goal.completed ? `<button class="btn small" onclick="completeAstralGoal('${goal.id}')">‚úì Complete</button>` : ''}
          <button class="btn small" onclick="editAstralGoal('${goal.id}')">Edit</button>
          <button class="btn small" onclick="deleteAstralGoal('${goal.id}')">Delete</button>
        </div>
      `;
      
      if(goal.completed) {
        completedList.appendChild(div);
      } else {
        activeList.appendChild(div);
      }
    });
    
    if(!activeList.children.length) {
      activeList.innerHTML = '<div class="empty" style="padding:20px; text-align:center; color:var(--muted)">No active goals yet</div>';
    }
    if(!completedList.children.length) {
      completedList.innerHTML = '<div class="empty" style="padding:20px; text-align:center; color:var(--muted)">No completed goals yet</div>';
    }
  }

  // Global astral goal functions
  window.completeAstralGoal = (id) => {
    const goal = state.astralGoals.find(g => g.id === id);
    if(goal) {
      goal.completed = true;
      goal.completedDate = new Date().toISOString();
      save();
      renderAstralGoals();
    }
  };

  window.editAstralGoal = (id) => {
    const goal = state.astralGoals.find(g => g.id === id);
    if(goal) openAstralGoalEditor(goal);
  };

  window.deleteAstralGoal = async (id) => {
    if(await askConfirm('Delete this goal?')) {
      state.astralGoals = state.astralGoals.filter(g => g.id !== id);
      save();
      renderAstralGoals();
    }
  };

  function renderAstralTechniques() {
    console.log('Rendering astral techniques, count:', state.astralTechniques?.length || 0);
    const list = qs('#astralTechniquesList');
    if(!list) {
      console.warn('Astral techniques list not found');
      return;
    }
    
    list.innerHTML = '';
    
    (state.astralTechniques || []).forEach(technique => {
      const card = document.createElement('div');
      card.className = 'technique-card';
      
      const stars = Array.from({length: 5}, (_, i) => 
        `<span class="star ${i < technique.rating ? 'filled' : ''}" style="pointer-events:none">‚òÖ</span>`
      ).join('');
      
      card.innerHTML = `
        <h4>${technique.name}</h4>
        <div style="font-size:12px; color:var(--muted); margin-bottom:8px">${technique.type}</div>
        <div class="technique-rating">${stars}</div>
        <div style="margin:8px 0">${technique.description}</div>
        ${technique.notes ? `<div style="font-size:12px; color:var(--muted); border-top:1px solid var(--border); padding-top:8px; margin-top:8px">${technique.notes}</div>` : ''}
        <div style="display:flex; gap:6px; margin-top:12px">
          <button class="btn small" onclick="editAstralTechnique('${technique.id}')">Edit</button>
          <button class="btn small" onclick="deleteAstralTechnique('${technique.id}')">Delete</button>
        </div>
      `;
      
      list.appendChild(card);
    });
    
    if(!list.children.length) {
      list.innerHTML = '<div class="empty">No techniques added yet</div>';
    }
  }

  // Global astral technique functions  
  window.editAstralTechnique = (id) => {
    const technique = state.astralTechniques.find(t => t.id === id);
    if(technique) openAstralTechniqueEditor(technique);
  };

  window.deleteAstralTechnique = async (id) => {
    if(await askConfirm('Delete this technique?')) {
      state.astralTechniques = state.astralTechniques.filter(t => t.id !== id);
      save();
      renderAstralTechniques();
    }
  };

  function renderAstralProgress() {
    console.log('Rendering astral progress');
    const projections = state.projections || [];
    
    const successfulProjections = projections.filter(p => p.type === 'full' || p.type === 'partial');
    const successRate = projections.length ? Math.round((successfulProjections.length / projections.length) * 100) : 0;
    const avgDuration = successfulProjections.length ? 
      Math.round(successfulProjections.reduce((sum, p) => sum + (p.duration || 0), 0) / successfulProjections.length) : 0;
    const completedGoals = (state.astralGoals || []).filter(g => g.completed).length;
    
    const successEl = qs('#astralSuccessRate');
    const durationEl = qs('#astralDuration');
    const goalsEl = qs('#astralGoalsAchieved');
    const freqEl = qs('#astralFreq');
    
    if(successEl) successEl.textContent = `${successRate}%`;
    if(durationEl) durationEl.textContent = avgDuration.toString();
    if(goalsEl) goalsEl.textContent = completedGoals.toString();
    if(freqEl) freqEl.textContent = (projections.length / 4.3).toFixed(1);
    
    console.log('Progress stats:', { successRate, avgDuration, completedGoals, projections: projections.length });
  }

  // Projection modal handlers
  qs('#newProjection')?.addEventListener('click', () => openProjectionEditor());
  qs('#newAstralGoal')?.addEventListener('click', () => openAstralGoalEditor());
  qs('#newAstralTechnique')?.addEventListener('click', () => openAstralTechniqueEditor());

  function openProjectionEditor(projection = null) {
    currentProjectionEntry = projection;
    const modal = qs('#projectionModal');
    
    qs('#projectionTitle').value = projection?.title || '';
    qs('#projectionDate').value = projection?.date ? toLocalInput(projection.date) : toLocalInput(new Date().toISOString());
    qs('#projectionType').value = projection?.type || 'failed';
    qs('#projectionClarity').value = projection?.clarity || 5;
    qs('#clarityValue').textContent = projection?.clarity || 5;
    qs('#projectionDuration').value = projection?.duration || '';
    qs('#projectionDescription').innerHTML = projection?.description || '';
    qs('#projectionTagsInput').value = (projection?.tags || []).join(', ');
    qs('#projectionTechniqueSelect').value = projection?.technique || '';
    
    // Clear location buttons
    document.querySelectorAll('.location-btn').forEach(btn => btn.classList.remove('active'));
    
    // Set active locations
    if(projection?.locations) {
      projection.locations.forEach(location => {
        const btn = document.querySelector(`[data-location="${location}"]`);
        if(btn) btn.classList.add('active');
      });
    }
    
    modal.classList.add('open');
  }

  function openAstralGoalEditor(goal = null) {
    currentAstralGoal = goal;
    const modal = qs('#astralGoalModal');
    
    qs('#astralGoalTitle').value = goal?.title || '';
    qs('#astralGoalCategory').value = goal?.category || 'exploration';
    qs('#astralGoalDescription').value = goal?.description || '';
    qs('#astralGoalDifficulty').value = goal?.difficulty || 'medium';
    
    modal.classList.add('open');
  }

  function openAstralTechniqueEditor(technique = null) {
    currentAstralTechnique = technique;
    const modal = qs('#astralTechniqueModal');
    
    qs('#astralTechniqueName').value = technique?.name || '';
    qs('#astralTechniqueType').value = technique?.type || 'exit';
    qs('#astralTechniqueDescription').value = technique?.description || '';
    qs('#astralTechniqueNotes').value = technique?.notes || '';
    
    // Set star rating
    const stars = modal.querySelectorAll('.star');
    stars.forEach((star, i) => {
      star.classList.toggle('filled', i < (technique?.rating || 0));
    });
    
    modal.classList.add('open');
  }

  // Astral modal save handlers
  qs('#projectionSave')?.addEventListener('click', () => {
    const projectionData = {
      id: currentProjectionEntry?.id || uid(),
      title: qs('#projectionTitle').value.trim(),
      date: new Date(qs('#projectionDate').value).toISOString(),
      type: qs('#projectionType').value,
      clarity: parseInt(qs('#projectionClarity').value),
      duration: parseInt(qs('#projectionDuration').value) || 0,
      description: qs('#projectionDescription').innerHTML,
      tags: qs('#projectionTagsInput').value.split(',').map(t => t.trim()).filter(Boolean),
      locations: Array.from(document.querySelectorAll('.location-btn.active')).map(btn => btn.dataset.location),
      technique: qs('#projectionTechniqueSelect').value,
      challenges: Array.from(document.querySelectorAll('.emotion-btn.active[data-challenge]')).map(btn => btn.dataset.challenge),
      created: currentProjectionEntry?.created || Date.now()
    };
    
    if(currentProjectionEntry) {
      const idx = state.projections.findIndex(p => p.id === currentProjectionEntry.id);
      if(idx > -1) state.projections[idx] = projectionData;
    } else {
      if(!state.projections) state.projections = [];
      state.projections.push(projectionData);
    }
    
    save();
    closeModal(qs('#projectionModal'));
    renderProjections();
  });

  qs('#astralGoalSave')?.addEventListener('click', () => {
    const goalData = {
      id: currentAstralGoal?.id || uid(),
      title: qs('#astralGoalTitle').value.trim(),
      category: qs('#astralGoalCategory').value,
      description: qs('#astralGoalDescription').value.trim(),
      difficulty: qs('#astralGoalDifficulty').value,
      completed: currentAstralGoal?.completed || false,
      created: currentAstralGoal?.created || Date.now()
    };
    
    if(currentAstralGoal) {
      const idx = state.astralGoals.findIndex(g => g.id === currentAstralGoal.id);
      if(idx > -1) state.astralGoals[idx] = goalData;
    } else {
      if(!state.astralGoals) state.astralGoals = [];
      state.astralGoals.push(goalData);
    }
    
    save();
    closeModal(qs('#astralGoalModal'));
    renderAstralGoals();
  });

  qs('#astralTechniqueSave')?.addEventListener('click', () => {
    const rating = document.querySelectorAll('#astralTechniqueRating .star.filled').length;
    
    const techniqueData = {
      id: currentAstralTechnique?.id || uid(),
      name: qs('#astralTechniqueName').value.trim(),
      type: qs('#astralTechniqueType').value,
      description: qs('#astralTechniqueDescription').value.trim(),
      notes: qs('#astralTechniqueNotes').value.trim(),
      rating: rating,
      created: currentAstralTechnique?.created || Date.now()
    };
    
    if(currentAstralTechnique) {
      const idx = state.astralTechniques.findIndex(t => t.id === currentAstralTechnique.id);
      if(idx > -1) state.astralTechniques[idx] = techniqueData;
    } else {
      if(!state.astralTechniques) state.astralTechniques = [];
      state.astralTechniques.push(techniqueData);
    }
    
    save();
    closeModal(qs('#astralTechniqueModal'));
    renderAstralTechniques();
  });

  // Astral modal cancel handlers
  qs('#projectionCancel')?.addEventListener('click', () => closeModal(qs('#projectionModal')));
  qs('#astralGoalCancel')?.addEventListener('click', () => closeModal(qs('#astralGoalModal')));
  qs('#astralTechniqueCancel')?.addEventListener('click', () => closeModal(qs('#astralTechniqueModal')));

  // Location button handlers (for projections)
  document.addEventListener('click', (e) => {
    if(e.target.matches('.location-btn')) {
      e.target.classList.toggle('active');
    }
  });

  // Astral star rating handler
  document.addEventListener('click', (e) => {
    if(e.target.matches('#astralTechniqueRating .star')) {
      const rating = parseInt(e.target.dataset.rating);
      const stars = document.querySelectorAll('#astralTechniqueRating .star');
      stars.forEach((star, i) => {
        star.classList.toggle('filled', i < rating);
      });
    }
  });

  // Clarity slider handler
  qs('#projectionClarity')?.addEventListener('input', (e) => {
    qs('#clarityValue').textContent = e.target.value;
  });

  // ===== Dropbox Sync =====
  async function refreshAccessToken(){
    if(!state.sync?.refreshToken || !state.sync?.appKey) return false;
    try{
      const body = new URLSearchParams({
        grant_type:'refresh_token',
        refresh_token: state.sync.refreshToken,
        client_id: state.sync.appKey
      });
      const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body
      });
      if(!res.ok){
        console.error('Refresh token request failed', await res.text());
        return false;
      }
      const data = await res.json();
      state.sync.accessToken = data.access_token;
      state.sync.dropboxAccountId = data.account_id || state.sync.dropboxAccountId || '';
      state.sync.dropboxRootPath = state.sync.dropboxRootPath || BACKUP_ROOT_PATH;
      save();
      try{
        localStorage.setItem(syncKey, JSON.stringify({accessToken: state.sync.accessToken, refreshToken: state.sync.refreshToken, provider: state.sync.provider, dropboxAccountId: state.sync.dropboxAccountId, dropboxRootPath: state.sync.dropboxRootPath}));
      }catch{}
      return true;
    }catch(err){
      console.error('Refresh token error:', err);
      return false;
    }
  }

  async function dropboxApiCall(endpoint, options = {}) {
    if(!state.sync?.accessToken) {
      throw new Error('No access token available');
    }

    const url = `https://api.dropboxapi.com/2/${endpoint}`;
    const headers = {
      'Authorization': `Bearer ${state.sync.accessToken}`,
      'Content-Type': 'application/json',
      ...options.headers
    };

    let response = await fetch(url, {
      method: options.method || 'POST',
      headers,
      body: options.body
    });

    if(response.status === 401 && await refreshAccessToken()){
      headers['Authorization'] = `Bearer ${state.sync.accessToken}`;
      response = await fetch(url, {
        method: options.method || 'POST',
        headers,
        body: options.body
      });
    }

    if(!response.ok) {
      const errorText = await response.text();
      console.error('Dropbox API Error:', response.status, errorText);

      if(response.status === 401) {
        state.sync.accessToken = '';
        state.sync.refreshToken = '';
        save();
        throw new Error('Access token expired or invalid');
      }

      throw new Error(`Dropbox API error: ${response.status} - ${errorText}`);
    }

    return response;
  }

  async function listLatestBackup(){
    const root = state.sync?.dropboxRootPath || BACKUP_ROOT_PATH;
    const path = `${root}/backups`;
    let res = await dropboxApiCall('files/list_folder', {body: JSON.stringify({path})});
    let data = await res.json();
    let entries = data.entries || [];
    while(data.has_more){
      res = await dropboxApiCall('files/list_folder/continue', {body: JSON.stringify({cursor: data.cursor})});
      data = await res.json();
      entries = entries.concat(data.entries || []);
    }
    const candidates = entries.filter(e=>e['.tag']==='folder' || e['.tag']==='file');
    if(candidates.length===0) return null;
    candidates.sort((a,b)=>{
      const at=new Date(a.server_modified || a.client_modified || 0).getTime();
      const bt=new Date(b.server_modified || b.client_modified || 0).getTime();
      return bt-at;
    });
    return candidates[0];
  }

  async function showBackupPicker(){
    const root = state.sync?.dropboxRootPath || BACKUP_ROOT_PATH;
    const path = `${root}/backups`;
    let res = await dropboxApiCall('files/list_folder', {body: JSON.stringify({path})});
    let data = await res.json();
    let entries = data.entries || [];
    while(data.has_more){
      res = await dropboxApiCall('files/list_folder/continue', {body: JSON.stringify({cursor: data.cursor})});
      data = await res.json();
      entries = entries.concat(data.entries || []);
    }
    const candidates = entries.filter(e=>e['.tag']==='folder' || e['.tag']==='file');
    if(candidates.length===0){ alert('No backups found'); return null; }
    const list = candidates.map((e,i)=>`${i+1}. ${e.name}`).join('\n');
    const choice = prompt('Select a backup to restore:\n'+list);
    const idx = parseInt(choice,10)-1;
    if(isNaN(idx) || !candidates[idx]) return null;
    return candidates[idx];
  }

  async function dropboxContentApiCall(endpoint, content, filename, mode = 'overwrite') {
    if(!state.sync?.accessToken) {
      throw new Error('No access token available');
    }

    const url = `https://content.dropboxapi.com/2/${endpoint}`;
    const headers = {
      'Authorization': `Bearer ${state.sync.accessToken}`,
      'Content-Type': 'application/octet-stream',
      'Dropbox-API-Arg': JSON.stringify({
        path: filename,
        mode
      })
    };

    let response = await fetch(url, {
      method: 'POST',
      headers,
      body: content
    });

    if(response.status === 401 && await refreshAccessToken()){
      headers['Authorization'] = `Bearer ${state.sync.accessToken}`;
      response = await fetch(url, {
        method: 'POST',
        headers,
        body: content
      });
    }

    if(!response.ok) {
      const errorText = await response.text();
      console.error('Dropbox Content API Error:', response.status, errorText);

      if(response.status === 401) {
        state.sync.accessToken = '';
        state.sync.refreshToken = '';
        save();
        const err401 = new Error('Access token expired or invalid');
        err401.status = 401;
        throw err401;
      }

      const error = new Error(`Dropbox API error: ${response.status} - ${errorText}`);
      error.status = response.status;
      throw error;
    }

    return response;
  }

  function setSyncStatus(msg, progress){
    const el=qs('#syncStatus');
    const pct = typeof progress === 'number' ? ` (${Math.round(progress*100)}%)` : '';
    if(el) el.textContent = 'Status: ' + msg + pct;
    console.log('Sync status:', msg, progress);
  }

  function handleSyncError(err){
    console.error('Sync error:', err);
    let message = err.message || 'An error occurred';
    let action = null;
    switch(err?.code || err?.status){
      case 'AuthExpired':
      case 401:
        message = 'Authentication expired. Please reconnect to Dropbox.';
        action = () => startOAuth && startOAuth();
        break;
      case 'NotFound':
      case 404:
        message = 'Requested file not found on Dropbox.';
        action = () => openRestoreOptions && openRestoreOptions();
        break;
      case 'VersionTooNew':
        message = 'Backup was created with a newer app version. Please update and try again.';
        break;
      case 'IntegrityError':
        message = 'Downloaded data failed integrity checks.';
        break;
    }
    setSyncStatus(message);
    if(action && confirm(message + ' Open settings now?')){
      try{ action(); }catch(e){ console.error('CTA action failed', e); }
    }
  }
  
  async function dbxUpload(path, blob, rev){
    try {
      const mode = rev ? { '.tag': 'update', update: rev } : 'overwrite';
      const response = await dropboxContentApiCall('files/upload', blob, path, mode);
      const metadata = await response.json();
      state.sync.rev = metadata.rev;
      return { success: true };
    } catch(err) {
      console.error('Upload failed:', err);
      setSyncStatus('Upload failed: ' + err.message);
      throw err;
    }
  }

  async function dbxUploadChunked(blob, path, rev){
    if(!state.sync?.accessToken) {
      throw new Error('No access token available');
    }
    const CHUNK_SIZE = 8 * 1024 * 1024; // 8MB per chunk
    const totalSize = blob.size;
    let offset = 0;
    let sessionId;
    try{
      // Start session
      let chunk = blob.slice(0, CHUNK_SIZE);
      let headers = {
        'Authorization': `Bearer ${state.sync.accessToken}`,
        'Content-Type': 'application/octet-stream',
        'Dropbox-API-Arg': JSON.stringify({close:false})
      };
      let url = 'https://content.dropboxapi.com/2/files/upload_session/start';
      let res = await fetch(url, {method:'POST', headers, body:chunk});
      if(res.status === 401 && await refreshAccessToken()){
        headers['Authorization'] = `Bearer ${state.sync.accessToken}`;
        res = await fetch(url, {method:'POST', headers, body:chunk});
      }
      if(!res.ok){
        const t = await res.text();
        const error = new Error(`Dropbox chunk start failed: ${res.status} - ${t}`);
        error.status = res.status;
        throw error;
      }
      const data = await res.json();
      sessionId = data.session_id;
      offset += chunk.size;
      setSyncStatus(`Uploading ${path}`, offset/totalSize);

      while(offset < totalSize){
        chunk = blob.slice(offset, offset + CHUNK_SIZE);
        const isLast = offset + chunk.size >= totalSize;
        url = isLast
          ? 'https://content.dropboxapi.com/2/files/upload_session/finish'
          : 'https://content.dropboxapi.com/2/files/upload_session/append_v2';
        const apiArg = isLast
          ? {cursor:{session_id:sessionId, offset}, commit:{path, mode: rev ? { '.tag':'update', update: rev } : 'overwrite'}}
          : {cursor:{session_id:sessionId, offset}, close:false};
        headers = {
          'Authorization': `Bearer ${state.sync.accessToken}`,
          'Content-Type': 'application/octet-stream',
          'Dropbox-API-Arg': JSON.stringify(apiArg)
        };
        res = await fetch(url, {method:'POST', headers, body:chunk});
        if(res.status === 401 && await refreshAccessToken()){
          headers['Authorization'] = `Bearer ${state.sync.accessToken}`;
          res = await fetch(url, {method:'POST', headers, body:chunk});
        }
        if(!res.ok){
          const t = await res.text();
          const error = new Error(`Dropbox chunk ${isLast?'finish':'append'} failed: ${res.status} - ${t}`);
          error.status = res.status;
          throw error;
        }
        offset += chunk.size;
        setSyncStatus(`Uploading ${path}`, offset/totalSize);
        if(isLast){
          const metadata = await res.json();
          state.sync.rev = metadata.rev;
        }
      }
      return {success:true};
    }catch(err){
      console.error('Chunked upload failed:', err);
      setSyncStatus('Upload failed: ' + err.message);
      throw err;
    }
  }

  async function dbxDownloadStream(path){
    if(!state.sync?.accessToken) {
      throw new Error('No access token available');
    }

    const url = 'https://content.dropboxapi.com/2/files/download';
    const headers = {
      'Authorization': `Bearer ${state.sync.accessToken}`,
      'Dropbox-API-Arg': JSON.stringify({ path })
    };

    let response = await fetch(url, {
      method: 'POST',
      headers
    });

    if(response.status === 401 && await refreshAccessToken()){
      headers['Authorization'] = `Bearer ${state.sync.accessToken}`;
      response = await fetch(url, {
        method: 'POST',
        headers
      });
    }

    if(!response.ok) {
      const errorText = await response.text();
      if(response.status === 401){
        state.sync.accessToken = '';
        state.sync.refreshToken = '';
        save();
      }
      const err = new Error(`Download failed: ${response.status} - ${errorText}`);
      err.status = response.status;
      if(response.status === 401) err.code = 'AuthExpired';
      else if(response.status === 404) err.code = 'NotFound';
      throw err;
    }

    return response;
  }

  async function parseJsonArrayStream(response, onItem, onProgress){
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let depth = 0;
    let inString = false;
    let start = 0;
    let bytesRead = 0;
    const total = Number(response.headers.get('Content-Length')) || 0;
    while(true){
      const {value, done} = await reader.read();
      if(done) break;
      bytesRead += value.byteLength;
      buffer += decoder.decode(value, {stream:true});
      for(let i=0;i<buffer.length;i++){
        const ch = buffer[i];
        if(ch === '"' && buffer[i-1] !== '\\') inString = !inString;
        if(inString) continue;
        if(ch === '{'){
          if(depth++ === 0) start = i;
        }else if(ch === '}'){
          if(--depth === 0){
            const objStr = buffer.slice(start, i+1);
            try{ onItem(JSON.parse(objStr)); }catch(e){ console.error('JSON parse error', e); }
            buffer = buffer.slice(i+1);
            i = -1;
          }
        }
      }
      onProgress && onProgress(bytesRead, total);
    }
    return bytesRead;
  }

  async function dbxDownload(path){
    const response = await dbxDownloadStream(path);

    if(path === (state.sync?.path || '/Apps/DR Script Builder/data.json')){
      const meta = response.headers.get('Dropbox-API-Result');
      if(meta){
        try{
          const metadata = JSON.parse(meta);
          state.sync.rev = metadata.rev;
        }catch(e){
          console.warn('Failed to parse Dropbox-API-Result', e);
        }
      }
    }

    return response.blob();
  }

  const MEDIA_CHUNK_SIZE = 10 * 1024 * 1024;
  const mediaHashMismatches = [];

  async function dbxDownloadVerified(path, expectedHash){
    if(!state.sync?.accessToken){
      throw new Error('No access token available');
    }

    const baseHeaders = {
      'Authorization': `Bearer ${state.sync.accessToken}`,
      'Dropbox-API-Arg': JSON.stringify({ path })
    };
    const url = 'https://content.dropboxapi.com/2/files/download';

    let response = await fetch(url, {method:'POST', headers:{...baseHeaders, Range:'bytes=0-0'}});
    if(response.status === 401 && await refreshAccessToken()){
      baseHeaders['Authorization'] = `Bearer ${state.sync.accessToken}`;
      response = await fetch(url, {method:'POST', headers:{...baseHeaders, Range:'bytes=0-0'}});
    }
    if(!response.ok){
      const t = await response.text();
      const err = new Error(`Download failed: ${response.status} - ${t}`);
      err.status = response.status;
      if(response.status === 401) err.code = 'AuthExpired';
      else if(response.status === 404) err.code = 'NotFound';
      throw err;
    }

    const meta = response.headers.get('Dropbox-API-Result');
    const metadata = meta ? JSON.parse(meta) : {};
    const size = metadata.size || 0;
    const chunks = [await response.arrayBuffer()];
    let offset = 1;
    while(offset < size){
      const end = Math.min(offset + MEDIA_CHUNK_SIZE - 1, size - 1);
      let r = await fetch(url, {method:'POST', headers:{...baseHeaders, Range:`bytes=${offset}-${end}`}});
      if(r.status === 401 && await refreshAccessToken()){
        baseHeaders['Authorization'] = `Bearer ${state.sync.accessToken}`;
        r = await fetch(url, {method:'POST', headers:{...baseHeaders, Range:`bytes=${offset}-${end}`}});
      }
      if(!r.ok){
        const t = await r.text();
        const err = new Error(`Download chunk failed: ${r.status} - ${t}`);
        err.status = r.status;
        if(r.status === 401) err.code = 'AuthExpired';
        else if(r.status === 404) err.code = 'NotFound';
        throw err;
      }
      chunks.push(await r.arrayBuffer());
      offset = end + 1;
    }

    const blob = new Blob(chunks, {type: metadata?.mime_type || 'application/octet-stream'});
    if(expectedHash && metadata?.content_hash && expectedHash !== metadata.content_hash){
      mediaHashMismatches.push({path, expected: expectedHash, actual: metadata.content_hash});
      const err = new Error('Content hash mismatch');
      err.code = 'IntegrityError';
      throw err;
    }
    return {blob, contentHash: metadata.content_hash};
  }
  
  async function syncPush(silent = false){ 
    try{
      if(!silent) setSyncStatus('Pushing to Dropbox...', 0);
      
      if(!state.sync?.accessToken) {
        throw new Error('No access token - please connect Dropbox first');
      }

      const json = JSON.stringify(state);
      const blob = new Blob([json], {type:'application/json'});
      const path = (state.sync?.path) || '/Apps/DR Script Builder/data.json';

      const THRESHOLD = 150 * 1024 * 1024;
      try{
        if(blob.size > THRESHOLD){
          await dbxUploadChunked(blob, path, state.sync.rev);
        }else{
          await dbxUpload(path, blob, state.sync.rev);
        }
      }catch(err){
        console.warn('Standard upload failed, retrying chunked', err);
        await dbxUploadChunked(blob, path, state.sync.rev);
      }
      state.sync.lastSync = Date.now();
      let quota=false;
      try{
        localStorage.setItem(storeKey, JSON.stringify(state));
      }catch(err){
        if(err?.name==='QuotaExceededError'){
          quota=true;
          console.warn('Storage quota exceeded, state not fully saved');
        }
      }
      try{
        localStorage.setItem(syncKey, JSON.stringify({accessToken: state.sync.accessToken, refreshToken: state.sync.refreshToken, provider: state.sync.provider, dropboxAccountId: state.sync.dropboxAccountId, dropboxRootPath: state.sync.dropboxRootPath}));
      }catch(err){
        if(err?.name==='QuotaExceededError'){
          quota=true;
          console.warn('Storage quota exceeded, sync token not saved');
        }
      }
      if(quota){ setSyncStatus('Warning: storage full - data may not be saved'); }
      if(!silent) setSyncStatus('Pushed at ' + new Date(state.sync.lastSync).toLocaleString());
    }catch(err){
      console.error('Push failed:', err);
      if(err.status === 409){
        alert('Sync conflict detected. The Dropbox file has been modified elsewhere.');
        if(confirm('Pull the latest version and overwrite local data?')){
          try{ await syncPull(); }
          catch(e){ console.error('Auto-pull after conflict failed', e); }
        }
      }
      if(!silent) handleSyncError(err);
      throw err;
    }
  }

  function openRestoreOptions(){
    if(!state.sync?.accessToken){
      alert('Connect Dropbox first.');
      return;
    }
    lastFocusedElement = document.activeElement;
    const modal = qs('#restoreModal');
    const fileInput = qs('#restoreFile');
    if(fileInput){
      fileInput.value='';
      fileInput.style.display='none';
    }
    const targetLatest = modal?.querySelector('input[name="restoreTarget"][value="latest"]');
    if(targetLatest) targetLatest.checked = true;
    const strategyOverwrite = modal?.querySelector('input[name="restoreStrategy"][value="overwrite"]');
    if(strategyOverwrite) strategyOverwrite.checked = true;
    modal?.classList.add('open');
    modal?.setAttribute('aria-hidden','false');
  }

  const restoreModal = qs('#restoreModal');
  const restoreFileInput = qs('#restoreFile');
  const restoreCancel = qs('#restoreCancel');
  const restoreConfirm = qs('#restoreConfirm');
  const restoreLatestRadio = restoreModal?.querySelector('input[name="restoreTarget"][value="latest"]');
  const restoreFileRadio = restoreModal?.querySelector('input[name="restoreTarget"][value="file"]');

  restoreCancel?.addEventListener('click', ()=>{ closeModal(restoreModal); restoreModal?.setAttribute('aria-hidden','true'); });
  restoreConfirm?.addEventListener('click', ()=>{
    const opts = {
      target: restoreModal?.querySelector('input[name="restoreTarget"]:checked')?.value,
      strategy: restoreModal?.querySelector('input[name="restoreStrategy"]:checked')?.value,
      appState: qs('#restoreAppState')?.checked,
      scenarios: qs('#restoreScenarios')?.checked,
      media: qs('#restoreMedia')?.checked,
      settings: qs('#restoreSettings')?.checked,
      file: restoreFileInput?.files?.[0] || null
    };
    closeModal(restoreModal);
    restoreModal?.setAttribute('aria-hidden','true');
    startDropboxRestore(opts);
  });

  restoreLatestRadio?.addEventListener('change', ()=>{
    if(restoreFileInput){ restoreFileInput.style.display='none'; restoreFileInput.value=''; }
  });
  restoreFileRadio?.addEventListener('change', ()=>{
    if(restoreFileInput){ restoreFileInput.style.display='inline-block'; }
  });

  async function startDropboxRestore(opts){
    try{
      restoreSnapshot = JSON.stringify(state);
      setSyncStatus('Restoring from Dropbox...');
      const root = state.sync?.dropboxRootPath || BACKUP_ROOT_PATH;
      if(opts.media){
        const indexResponse = await dbxDownloadStream(`${root}/${MEDIA_INDEX_FILE}`);
        const entries = [];
        await parseJsonArrayStream(indexResponse, item=>entries.push(item), (loaded,total)=>setSyncStatus('Fetching media index', loaded/total));
        const itemsPlanned = entries.length;
        const totalBytes = entries.reduce((s,i)=>s + (i.bytes||0),0);
        let completedBytes = 0;
        let itemsImported = 0;
        const skippedMedia = [];
        const startTime = performance.now();
        async function worker(){
          while(entries.length){
            const item = entries.shift();
            if(!item) continue;
            const rel = item.path || item.path_display || item.name;
            const expected = item.sha256 || item.content_hash || item.hash;
            const fullPath = `${root}/media/${rel}`;
            try{
              const {blob} = await dbxDownloadVerified(fullPath, expected);
              completedBytes += item.bytes || blob.size || 0;
              itemsImported++;
              setSyncStatus(`Restoring media ${itemsImported}/${itemsPlanned}`, completedBytes/Math.max(totalBytes,1));
            }catch(err){
              skippedMedia.push(fullPath);
              handleSyncError(err);
            }
          }
        }
        await Promise.all(Array.from({length:4}, ()=>worker()));
        const elapsed = performance.now() - startTime;
        console.log('Restore diagnostics',{timeMs:elapsed,totalBytes:completedBytes,items:itemsImported,conflicts:mediaHashMismatches.length,skippedMedia:skippedMedia.length});
        if(skippedMedia.length){ console.warn('Skipped media files:', skippedMedia); }
      }
      if(opts.appState || opts.scenarios || opts.settings){
        await syncPull();
      }
      if(mediaHashMismatches.length){
        console.warn('Hash mismatches detected:', mediaHashMismatches);
      }
      setSyncStatus('Restore complete');
      qs('#undoRestore')?.style.display='inline-block';
    }catch(err){
      restoreSnapshot = null;
      console.error('Restore failed:', err);
      handleSyncError(err);
    }
  }
  function undoRestore(){
    if(!restoreSnapshot) return;
    try{
      state = JSON.parse(restoreSnapshot);
      save();
      renderAll();
      restoreSnapshot = null;
      qs('#undoRestore')?.style.display='none';
      setSyncStatus('Restore undone');
    }catch(err){
      console.error('Undo restore failed', err);
      alert('Undo restore failed: '+(err?.message||err));
    }
  }

  function parseConflictLine(line){
    const m = line.match(/^(\S+)\s+(\w+):([^\s]+)\s+->\s+(.+)$/);
    if(!m) return null;
    return { timestamp: m[1], type: m[2], id: m[3], file: m[4], date: new Date(m[1]) };
  }

  async function openConflictLog(){
    try{
      const res = await fetch('data/merge.log');
      const text = await res.text();
      conflictLogData = text.trim().split('\n').map(parseConflictLine).filter(Boolean);
      const sel = qs('#conflictTypeFilter');
      if(sel){
        const types = Array.from(new Set(conflictLogData.map(e=>e.type)));
        sel.innerHTML = '<option value="all">All Types</option>' + types.map(t=>`<option value="${t}">${t}</option>`).join('');
      }
      applyConflictFilters();
      const modal = qs('#conflictLogModal');
      modal?.classList.add('open');
      modal?.setAttribute('aria-hidden','false');
    }catch(err){
      console.error('Failed to load conflict log', err);
      alert('Failed to load conflict log');
    }
  }

  function applyConflictFilters(){
    let entries = conflictLogData;
    const type = qs('#conflictTypeFilter')?.value || 'all';
    const start = qs('#conflictStartDate')?.value;
    const end = qs('#conflictEndDate')?.value;
    if(type !== 'all') entries = entries.filter(e=>e.type===type);
    if(start){
      const sd = new Date(start);
      entries = entries.filter(e=>e.date >= sd);
    }
    if(end){
      const ed = new Date(end);
      ed.setDate(ed.getDate()+1);
      entries = entries.filter(e=>e.date < ed);
    }
    const pre = qs('#conflictLogEntries');
    if(pre){
      pre.textContent = entries.map(e=>`${e.timestamp} ${e.type}:${e.id} -> ${e.file}`).join('\n') || 'No conflicts found';
    }
  }

  async function syncPull(){
    try{
      setSyncStatus('Pulling from Dropbox...');
      
      if(!state.sync?.accessToken) {
        throw new Error('No access token - please connect Dropbox first');
      }
      
      const path = (state.sync?.path) || '/Apps/DR Script Builder/data.json';
      const file = await dbxDownload(path);
      const rev = state.sync.rev;
      const text = await file.text();
      const incoming = JSON.parse(text);
      if(incoming?.appVersion && incoming.appVersion > APP_VERSION){
        const err = new Error('Backup version too new');
        err.code = 'VersionTooNew';
        throw err;
      }

      incoming.sync = incoming.sync || {};
      incoming.sync.rev = rev;
      state = incoming;

      const now = new Date().toISOString();
      const hashes = {
        scenarios: await hashJson(state.scenarios),
        characters: await hashJson(state.characters),
        locations: await hashJson(state.locations),
        settings: await hashJson(state.settings),
        media: await hashJson(state.media)
      };
      await saveToIndexedDB({
        scenarios: state.scenarios || [],
        characters: state.characters || [],
        locations: state.locations || [],
        settings: state.settings || {},
        media: state.media || []
      }, {lastPullFromDropboxAt: now, sourcePath: path, hashes});
      await refreshInMemoryStores();
      recomputeDerivedFields();
      rebuildCaches();
      reconnectAudioBindings();
      cleanupStateMedia();
      state.sync = state.sync || {};
      state.sync.syncMeta = { lastPullFromDropboxAt: now, sourcePath: path, hashes };
      let quota=false;
      try{
        localStorage.setItem(storeKey, JSON.stringify(state));
      }catch(err){
        if(err?.name==='QuotaExceededError'){
          quota=true;
          console.warn('Storage quota exceeded, state not fully saved');
        }
      }
      try{
        localStorage.setItem(syncKey, JSON.stringify({accessToken: state.sync.accessToken, refreshToken: state.sync.refreshToken, provider: state.sync.provider, dropboxAccountId: state.sync.dropboxAccountId, dropboxRootPath: state.sync.dropboxRootPath}));
      }catch(err){
        if(err?.name==='QuotaExceededError'){
          quota=true;
          console.warn('Storage quota exceeded, sync token not saved');
        }
      }
      if(quota){ setSyncStatus('Warning: storage full - data may not be saved'); }
      setSyncStatus('Pulled at ' + new Date().toLocaleString());
      renderAll();
    }catch(err){
      console.error('Pull failed:', err);
      handleSyncError(err);
      throw err;
    }
  }

  function base64urlEncode(buffer){
    let binary='';
    const bytes = new Uint8Array(buffer);
    bytes.forEach(b=>binary+=String.fromCharCode(b));
    return btoa(binary).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/, '');
  }

  function generateCodeVerifier(){
    const array = new Uint8Array(64);
    crypto.getRandomValues(array);
    return base64urlEncode(array);
  }

  async function generateCodeChallenge(verifier){
    const data = new TextEncoder().encode(verifier);
    const digest = await crypto.subtle.digest('SHA-256', data);
    return base64urlEncode(digest);
  }

  async function startOAuth(){
    try{
      const appKey=(qs('#dbxAppKey')?.value||'').trim();
      if(!appKey){
        alert('Please enter your Dropbox App Key first.');
        return;
      }

      state.sync.appKey = appKey;
      state.sync.provider = 'dropbox';
      save();

      const redirectUri = window.location.origin + window.location.pathname;
      const codeVerifier = generateCodeVerifier();
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      localStorage.setItem('dbxCodeVerifier', codeVerifier);
      const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${appKey}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&code_challenge_method=S256&code_challenge=${codeChallenge}&token_access_type=offline`;

      setSyncStatus('Redirecting to Dropbox for authorization...');
      window.location.href = authUrl;
    }catch(err){
      console.error('OAuth start failed:', err);
      setSyncStatus('OAuth failed: ' + (err?.message || err));
      alert('OAuth start failed: '+(err?.message||err));
    }
  }

  async function tryHandleOAuthRedirect(){
    try{
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      if(!code) return false;
      const verifier = localStorage.getItem('dbxCodeVerifier');
      localStorage.removeItem('dbxCodeVerifier');
      if(!verifier) return false;
      const redirectUri = window.location.origin + window.location.pathname;
      const body = new URLSearchParams({
        grant_type:'authorization_code',
        code,
        client_id: state.sync.appKey || (qs('#dbxAppKey')?.value||'').trim(),
        redirect_uri: redirectUri,
        code_verifier: verifier
      });
      const resp = await fetch('https://api.dropboxapi.com/oauth2/token', {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body
      });
      if(!resp.ok){
        console.error('Token exchange failed', await resp.text());
        setSyncStatus('OAuth failed: token exchange error');
        return false;
      }
      const data = await resp.json();
      state.sync.accessToken = data.access_token;
      state.sync.refreshToken = data.refresh_token;
      state.sync.provider = 'dropbox';
      state.sync.dropboxAccountId = data.account_id || state.sync.dropboxAccountId || '';
      state.sync.dropboxRootPath = state.sync.dropboxRootPath || BACKUP_ROOT_PATH;
      save();
      try{
        localStorage.setItem(syncKey, JSON.stringify({accessToken: state.sync.accessToken, refreshToken: state.sync.refreshToken, provider: state.sync.provider, dropboxAccountId: state.sync.dropboxAccountId, dropboxRootPath: state.sync.dropboxRootPath}));
      }catch{}
      params.delete('code');
      params.delete('state');
      const newUrl = window.location.pathname + (params.toString()?`?${params}`:'');
      window.history.replaceState({}, document.title, newUrl);
      setSyncStatus('Connected via OAuth');
      return true;
    }catch(err){
      console.error('Token parsing failed:', err);
    }
    return false;
  }

  function renderSettings(){ 
    const s=state.sync||{}; 
    const appKeyEl=qs('#dbxAppKey'); 
    const tokEl=qs('#dbxAccessToken'); 
    const pathEl=qs('#dbxPath'); 
    const autoEl=qs('#autoSyncToggle'); 
    const minsEl=qs('#autoSyncMins'); 
    if(appKeyEl) appKeyEl.value=s.appKey||''; 
    if(tokEl) tokEl.value=s.accessToken||''; 
    if(pathEl) pathEl.value=s.path||'/Apps/DR Script Builder/data.json'; 
    if(autoEl) autoEl.checked=!!s.auto; 
    if(minsEl) minsEl.value=String(s.intervalMins||5); 
    setSyncStatus(s.accessToken? 'Connected' : 'Not connected'); 
  }
  
  function attachSettingsHandlers(){
    qs('#dbxConnect')?.addEventListener('click', ()=>{ 
      const appKey = (qs('#dbxAppKey')?.value||'').trim();
      if(!appKey) {
        alert('Please enter your Dropbox App Key first.');
        return;
      }
      startOAuth(); 
    });
    
    qs('#dbxSaveToken')?.addEventListener('click', ()=>{ 
      const t=(qs('#dbxAccessToken')?.value||'').trim(); 
      if(!t){ 
        alert('Paste an access token first'); 
        return; 
      }
      
      state.sync.accessToken=t;
      state.sync.refreshToken='';
      state.sync.provider='dropbox';
      state.sync.appKey=(qs('#dbxAppKey')?.value||'').trim();
      state.sync.path=(qs('#dbxPath')?.value||'/Apps/DR Script Builder/data.json');
      save(); 
      
      testDropboxConnection();
    });
    
    qs('#dbxDisconnect')?.addEventListener('click', ()=>{
      state.sync.accessToken='';
      state.sync.refreshToken='';
      save();
      setSyncStatus('Disconnected');
    });
    qs('#dbxPath')?.addEventListener('change', e=>{ 
      state.sync.path=e.target.value; 
      save(); 
    });
    qs('#autoSyncToggle')?.addEventListener('change', e=>{ 
      state.sync.auto=!!e.target.checked; 
      save(); 
      setupAutoSync(); 
    });
    qs('#autoSyncMins')?.addEventListener('change', e=>{ 
      const n=parseInt(e.target.value,10); 
      state.sync.intervalMins=isNaN(n)?5:Math.max(1,n); 
      save(); 
      setupAutoSync(); 
    });
    qs('#syncNow')?.addEventListener('click', ()=>{
      if(!state.sync?.accessToken){
        alert('Connect Dropbox first.');
        return;
      }
      syncPush(false);
    });
    const restoreHandler=()=>{
      openRestoreOptions();
    };
    qs('#restoreFromDropbox')?.addEventListener('click', restoreHandler);
    qs('#qaRestore')?.addEventListener('click', restoreHandler);
    qs('#viewConflictLog')?.addEventListener('click', openConflictLog);
    qs('#conflictClose')?.addEventListener('click', ()=>{ closeModal(qs('#conflictLogModal')); });
    ['conflictTypeFilter','conflictStartDate','conflictEndDate'].forEach(id=>{
      qs('#'+id)?.addEventListener('change', applyConflictFilters);
    });
    qs('#undoRestore')?.addEventListener('click', undoRestore);
    qs('#testConnection')?.addEventListener('click', ()=>{
      testDropboxConnection();
    });
  }
  
  async function testDropboxConnection() {
    try {
      setSyncStatus('Testing connection...');
      
      if(!state.sync?.accessToken) {
        setSyncStatus('Failed: No access token');
        return;
      }
      
      const response = await dropboxApiCall('users/get_current_account');
      const result = await response.json();
      
      setSyncStatus(`Connected successfully as ${result.name.display_name}`);
      
    } catch(err) {
      console.error('Connection test failed:', err);
      setSyncStatus(`Failed: ${err.message}`);
    }
  }
  
  let autoTimer=null; 
  function setupAutoSync(){ 
    if(autoTimer){ 
      clearInterval(autoTimer); 
      autoTimer=null; 
    } 
    if(state.sync?.auto && state.sync?.accessToken){ 
      autoTimer=setInterval(()=>{ 
        syncPush(true).catch(err => console.warn('Auto-sync failed:', err)); 
      }, Math.max(1, state.sync.intervalMins||5)*60*1000); 
    } 
  }

  // Export/Import functionality
  async function doExportAll(){
    try{
      const json = JSON.stringify(state, null, 2);
      if(window.showSaveFilePicker){
        const handle = await window.showSaveFilePicker({
          suggestedName: 'dr-script-builder-data.json',
          types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(new Blob([json], { type: 'application/json;charset=utf-8' }));
        await writable.close();
        setSyncStatus('Exported to chosen file');
        return;
      }

      const isFirefox = typeof navigator!=='undefined' && /firefox/i.test(navigator.userAgent);
      if(isFirefox){
        const dataUrl = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);
        const win = window.open(dataUrl, '_blank');
        if(win){ 
          setSyncStatus('Opened JSON in a new tab (use Save Page As‚Ä¶)'); 
          return; 
        }
      }

      const blob = new Blob([json], {type:'application/json;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; 
      a.download = 'dr-script-builder-data.json'; 
      a.rel='noopener';
      document.body.appendChild(a);
      a.dispatchEvent(new MouseEvent('click', {bubbles:true, cancelable:true, view:window}));
      setTimeout(()=>{ 
        a.remove(); 
        URL.revokeObjectURL(url); 
      }, 1500);
      setSyncStatus('Exported as download');
    }catch(err){ 
      console.error('Export failed', err); 
      alert('Export failed: '+(err?.message||err)); 
    }
  }
  
  qs('#exportAll')?.addEventListener('click', ()=>{ doExportAll(); });
  qs('#importBtn')?.addEventListener('click', ()=> qs('#importFile')?.click());
  qs('#importFile')?.addEventListener('change', (e)=>{
    const f = e.target.files?.[0]; 
    if(!f) return;
    const r = new FileReader();
    r.onload = ()=>{
      try{
        const incoming = JSON.parse(r.result);
        if(!incoming || typeof incoming!=='object') throw new Error('Invalid JSON');
        state = incoming;
        ensureLibraries();
        initActiveLibrary();
        renderLibrarySelector();
        cleanupStateMedia();
        save();
        renderAll();
        setSyncStatus('Imported local file');
      }catch(err){ 
        console.error('Import failed', err); 
        alert('Import failed: '+(err?.message||err)); 
      }
    };
    r.readAsText(f);
    e.target.value='';
  });

  // ===== Boot =====
  function renderAll(){ 
    renderPortals(); 
    renderJournal(); 
    renderWR();
    renderPlaylists();
    renderVisualizers();
    filterScenarios();
    renderCollections();
    if(views.settings && !views.settings.hidden){
      renderSettings();
    }
    if(views.lucid && !views.lucid.hidden){ 
      renderLucidDreaming(); 
    } 
    if(views.astral && !views.astral.hidden){ 
      renderAstralProjection(); 
    } 
  }
  
  Object.keys(views).forEach(k=>{
    if(views[k]) views[k].hidden = (k!=='portals');
  });

  tryHandleOAuthRedirect();
  window.addEventListener('load', () => {
    initStarfield();
    requestAnimationFrame(drawStarfield);
    sizePortalCanvas();
    renderPortalScene();
  });
  // Delay heavy initialization until the user enters the app
  const enterBtn = qs('#enterApp');
  if (!enterBtn) {
    console.warn('Enter App button not found');
  } else {
    enterBtn.addEventListener('click', () => {
      const launch = qs('#launchScene');
      const app = qs('.app');
      qs('#portals-view').appendChild(portalCanvas);
      sizePortalCanvas();
      renderPortalScene();
      launch.style.opacity = '0';
      app.style.display = 'grid';
      requestAnimationFrame(() => {
        app.style.opacity = '1';
        // Use idle callback when available to keep the UI responsive
        (window.requestIdleCallback || requestAnimationFrame)(() => {
          renderAll();
          attachSettingsHandlers();
          setupAutoSync();
        });
      });
      setTimeout(() => launch.style.display = 'none', 500);
    });
  }

  console.log('DR Script Builder loaded successfully');
</script>
</body>
</html>
